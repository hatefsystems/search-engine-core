# ðŸŽ¯ Task 08.2: MMR Diversification

## ðŸ“… Sprint Info
- **Duration:** 3 days
- **Milestone:** M6 - Ranking Fusion
- **Priority:** P0 (Critical Path)
- **Depends On:** Task 08.1 (Feature Fusion) âœ…
- **Blocks:** Task 08.4 (Integration Testing)
- **Assignee:** TBD

## ðŸŽ¬ What You'll Build
Implement Maximal Marginal Relevance (MMR) algorithm to prevent domain repetition and ensure result diversity. Limit results per domain (â‰¤3 in top-10) while maintaining relevance across all languages.

## ðŸ“‹ Daily Breakdown

### Day 1: MMR Algorithm Implementation
- [ ] Implement core MMR algorithm
- [ ] Add domain extraction from URLs
- [ ] Build diversity scoring function
- [ ] Create relevance-diversity trade-off (lambda parameter)
- [ ] Add configurable domain limits
- [ ] Unit tests (30+ scenarios)

### Day 2: Optimization & Integration
- [ ] Performance optimization (<5ms for top-200)
- [ ] Integrate with feature fusion scores
- [ ] Add domain reputation weighting
- [ ] Handle edge cases (single domain results)
- [ ] Multi-language domain normalization
- [ ] Testing and validation

### Day 3: Configuration & Documentation
- [ ] Build diversity configuration system
- [ ] Add diversity metrics tracking
- [ ] Create monitoring dashboard
- [ ] Documentation and examples
- [ ] Integration testing

## âœ… Acceptance Criteria
- [ ] MMR diversification implemented
- [ ] Domain limit enforced (â‰¤3 per domain in top-10)
- [ ] Diversity improves by â‰¥20% vs no diversification
- [ ] Relevance maintained (NDCG drop <3%)
- [ ] Processing latency <5ms for top-200
- [ ] Works across all languages
- [ ] Configurable lambda (relevance-diversity trade-off)

## ðŸ“¦ Deliverables
- `src/ranking/Diversifier.cpp` (400 lines)
- `include/ranking/Diversifier.h` (100 lines)
- `tests/test_mmr_diversification.cpp` (40+ cases)
- `config/diversity_settings.yaml`
- `docs/ranking/mmr-diversification-guide.md`

## ðŸ”— MMR Algorithm

### Formula
```
MMR(d) = Î» * Relevance(d|q) - (1-Î») * max[Similarity(d, d_i)]
```
where d_i are already selected documents

### Implementation
```cpp
class Diversifier {
public:
    struct DiversityConfig {
        float lambda = 0.7f;  // Relevance vs diversity (0=pure diversity, 1=pure relevance)
        int max_per_domain = 3;  // Max results per domain
        bool enable_mmr = true;
    };
    
    std::vector<RankedDocument> diversify(
        const std::vector<RankedDocument>& candidates,
        const DiversityConfig& config = DiversityConfig()) {
        
        if (!config.enable_mmr) {
            return candidates;  // Return as-is
        }
        
        std::vector<RankedDocument> diversified;
        std::unordered_map<std::string, int> domain_counts;
        std::unordered_set<std::string> selected_ids;
        
        for (const auto& candidate : candidates) {
            std::string domain = extract_domain(candidate.doc_id);
            
            // Check domain limit
            if (domain_counts[domain] >= config.max_per_domain) {
                continue;  // Skip this document
            }
            
            // Compute MMR score
            float mmr_score = compute_mmr_score(
                candidate,
                diversified,
                config.lambda
            );
            
            // Add to diversified results
            RankedDocument diversified_doc = candidate;
            diversified_doc.final_score = mmr_score;
            diversified.push_back(diversified_doc);
            
            domain_counts[domain]++;
            selected_ids.insert(candidate.doc_id);
            
            if (diversified.size() >= candidates.size()) {
                break;
            }
        }
        
        return diversified;
    }

private:
    float compute_mmr_score(const RankedDocument& candidate,
                           const std::vector<RankedDocument>& selected,
                           float lambda) {
        if (selected.empty()) {
            return candidate.final_score;  // First document
        }
        
        // Find max similarity with already selected docs
        float max_similarity = 0.0f;
        for (const auto& selected_doc : selected) {
            float sim = compute_similarity(candidate, selected_doc);
            max_similarity = std::max(max_similarity, sim);
        }
        
        // MMR formula
        return lambda * candidate.final_score - (1 - lambda) * max_similarity;
    }
    
    float compute_similarity(const RankedDocument& a,
                            const RankedDocument& b) {
        // Domain-based similarity (same domain = high similarity)
        std::string domain_a = extract_domain(a.doc_id);
        std::string domain_b = extract_domain(b.doc_id);
        
        if (domain_a == domain_b) {
            return 1.0f;  // Same domain
        }
        
        // Could add content-based similarity here
        return 0.0f;
    }
    
    std::string extract_domain(const std::string& url) {
        // Extract eTLD+1 domain from URL
        // e.g., "https://www.example.com/path" -> "example.com"
        
        // Simplified implementation
        size_t start = url.find("://");
        if (start != std::string::npos) {
            start += 3;
        } else {
            start = 0;
        }
        
        size_t end = url.find("/", start);
        if (end == std::string::npos) {
            end = url.length();
        }
        
        std::string domain = url.substr(start, end - start);
        
        // Remove www. prefix
        if (domain.substr(0, 4) == "www.") {
            domain = domain.substr(4);
        }
        
        return domain;
    }
};
```

## ðŸ“Š Success Metrics
- **Diversity:** â‰¥20% improvement in domain distribution
- **Relevance:** NDCG drop <3%
- **Domain Limit:** â‰¤3 results per domain in top-10
- **Latency:** <5ms for 200 candidates
- **Coverage:** All languages

---

**Diverse results, satisfied users! ðŸŒˆðŸŽ¯**

