# üéØ Task 09.3: Query Expansion with Semantic Lexicon

## üìÖ Sprint Info
- **Duration:** 3 days
- **Milestone:** M6 - Ranking & Query Pipeline
- **Priority:** P1
- **Depends On:** Task 05.7 (Nightly Lexicon Export) ‚úÖ
- **Blocks:** Task 09.4 (Multi-Stage Retrieval)
- **Assignee:** TBD

## üé¨ What You'll Build
Implement intelligent query expansion using nightly-refreshed semantic lexicons. Add synonyms and related terms to improve recall while maintaining precision. Support any language automatically with configurable expansion limits (‚â§3 terms per query).

## üìã Daily Breakdown

### Day 1: Lexicon Integration & Expansion Logic
- [ ] Load semantic lexicons from Redis (multi-language)
- [ ] Implement synonym lookup with score thresholds
- [ ] Build query expansion algorithm (‚â§3 terms max)
- [ ] Add expansion confidence scoring
- [ ] Implement term weighting (original > expanded)
- [ ] Handle multi-language queries
- [ ] Performance optimization: <10ms per query
- [ ] Unit tests for expansion logic (40+ cases)

### Day 2: Expansion Strategies & Tuning
- [ ] Implement selective expansion (don't expand all terms)
- [ ] Add expansion blacklist (technical terms, names)
- [ ] Build expansion quality detector
- [ ] Tune score thresholds for precision/recall balance
- [ ] Test on query logs (if available)
- [ ] Add A/B test configuration
- [ ] Document expansion heuristics
- [ ] Performance benchmarking

### Day 3: Integration & Testing
- [ ] Integrate with query pipeline
- [ ] Add comprehensive test suite (60+ query patterns)
- [ ] Test recall improvement on diverse queries
- [ ] Precision validation (no junk expansions)
- [ ] Multi-language tests (10+ languages)
- [ ] Monitoring dashboard for expansion metrics
- [ ] Documentation and examples
- [ ] Code review preparation

## ‚úÖ Acceptance Criteria
- [ ] Query expansion improves recall by ‚â•15%
- [ ] Precision maintained: <5% precision loss
- [ ] Expansion limit: ‚â§3 terms per query (configurable)
- [ ] Expansion quality: synonyms are semantically relevant
- [ ] Latency: <10ms per query
- [ ] Works across 20+ languages automatically
- [ ] Term weighting: original query terms weighted higher
- [ ] Selective expansion: not all terms expanded

## üß™ Testing Checklist
- [ ] Unit tests for synonym lookup (30+ test cases)
- [ ] Expansion logic tests (40+ scenarios)
- [ ] Recall improvement tests (compare +/- expansion)
- [ ] Precision tests (no junk terms added)
- [ ] Multi-language tests (10+ languages)
- [ ] Performance benchmarks (<10ms)
- [ ] Edge cases (empty query, single word, technical terms)
- [ ] A/B test readiness validation

## üéâ Celebration Criteria (Definition of Done)
‚úÖ **Demo Ready:** Show query expansion improving results for tail queries
‚úÖ **Metric Met:** 15% recall improvement, <5% precision loss, <10ms latency
‚úÖ **Integration:** Seamlessly integrated into retrieval pipeline
‚úÖ **Quality:** Manual review confirms relevant expansions

**üéä Celebration Moment:** Tail queries now find relevant results!

## üì¶ Deliverables
- `src/pipeline/QueryExpander.h` (C++ header, 80 lines)
- `src/pipeline/QueryExpander.cpp` (C++ impl, 350-400 lines)
- `src/pipeline/ExpansionScorer.cpp` (scoring logic, 150 lines)
- `tests/test_query_expansion.cpp` (60+ test cases)
- `docs/query-expansion-guide.md`
- `monitoring/query_expansion_dashboard.json`

## üîó Dependencies & Integration

### Input
```cpp
struct ExpansionRequest {
    std::string query;           // Original query
    std::string language;        // Detected language
    int max_expansions;          // Max terms to add (default: 3)
    float score_threshold;       // Min similarity score (default: 0.7)
    bool enable_expansion;       // Feature flag
};
```

### Output
```cpp
struct ExpansionResult {
    std::string original_query;
    std::string expanded_query;  // Original + expansions
    std::vector<Expansion> expansions;
    
    struct Expansion {
        std::string original_term;
        std::vector<std::string> expanded_terms;
        std::vector<float> scores;
        std::string source;      // "synonym" | "related" | "misspelling"
    };
    
    float confidence;            // Overall expansion quality
    int expansion_count;         // Number of terms added
};
```

### Lexicon Format (from Task 05.7)
```json
{
    "term": "search",
    "language": "en",
    "expansions": [
        {"term": "find", "score": 0.85, "type": "synonym"},
        {"term": "lookup", "score": 0.78, "type": "synonym"},
        {"term": "query", "score": 0.75, "type": "related"}
    ],
    "version": "v1.20231115"
}
```

### Expansion Strategy
```cpp
// Selective expansion heuristics
1. Expand rare/specific terms (likely information need)
2. Don't expand common terms (already broad match)
3. Don't expand proper nouns/entity names
4. Weight original query terms higher than expansions
5. Limit total expansions to 3 terms
6. Use score threshold (‚â•0.7) for quality
```

### External Dependencies
- Redis (semantic lexicon storage)
- C++ standard library (string processing)

## üöÄ Next Steps
‚û°Ô∏è **Task 09.4: Multi-Stage Retrieval Pipeline** (4 days)
- Uses expanded query along with original and filtered versions
- Merges results from multiple retrieval passes

‚û°Ô∏è **Task 08.1: BM25 Weighted Retrieval** (3 days)
- Applies term weighting to original vs expanded terms
- Boosts original query terms in scoring

## üí° Tips & Resources

### Common Pitfalls
- ‚ö†Ô∏è **Over-expansion**: Adding too many terms hurts precision
- ‚ö†Ô∏è **Irrelevant synonyms**: Low-quality lexicons reduce quality
- ‚ö†Ô∏è **Equal weighting**: Original terms should be weighted higher
- ‚ö†Ô∏è **Expansion explosion**: Limit total query length
- ‚ö†Ô∏è **Technical terms**: Don't expand domain-specific jargon

### Helpful Resources
- [Query Expansion Techniques](https://nlp.stanford.edu/IR-book/html/htmledition/query-expansion-1.html)
- [Rocchio Algorithm](https://en.wikipedia.org/wiki/Rocchio_algorithm)
- [WordNet for Synonyms](https://wordnet.princeton.edu/)
- [fastText Semantic Similarity](https://fasttext.cc/)

### Example Code

#### Query Expander
```cpp
#include <redis++.h>
#include <vector>
#include <string>
#include <algorithm>

class QueryExpander {
public:
    QueryExpander(sw::redis::Redis* redis, float score_threshold = 0.7, int max_expansions = 3)
        : redis_(redis), score_threshold_(score_threshold), max_expansions_(max_expansions) {}
    
    ExpansionResult expand(const ExpansionRequest& request) {
        ExpansionResult result;
        result.original_query = request.query;
        
        // Tokenize query
        auto tokens = tokenize(request.query);
        
        // Expand each token selectively
        std::vector<std::string> expanded_tokens;
        int total_expansions = 0;
        
        for (const auto& token : tokens) {
            // Always keep original token
            expanded_tokens.push_back(token);
            
            // Check if we should expand this token
            if (should_expand(token, request.language) && total_expansions < max_expansions_) {
                auto expansions = get_expansions(token, request.language, request.score_threshold);
                
                // Add top expansion(s) up to limit
                int added = 0;
                for (const auto& exp : expansions) {
                    if (total_expansions < max_expansions_ && added < 1) {  // Max 1 expansion per token
                        expanded_tokens.push_back(exp.term);
                        result.expansions.push_back({token, {exp.term}, {exp.score}, "synonym"});
                        total_expansions++;
                        added++;
                    }
                }
            }
        }
        
        // Join expanded tokens
        result.expanded_query = join(expanded_tokens, " ");
        result.expansion_count = total_expansions;
        result.confidence = compute_confidence(result.expansions);
        
        return result;
    }
    
private:
    struct SynonymExpansion {
        std::string term;
        float score;
        std::string type;
    };
    
    bool should_expand(const std::string& token, const std::string& language) {
        // Selective expansion heuristics
        
        // Don't expand very common words (top 100 most frequent)
        if (is_very_common(token, language)) {
            return false;
        }
        
        // Don't expand proper nouns (capitalized)
        if (!token.empty() && std::isupper(token[0])) {
            return false;
        }
        
        // Don't expand single characters or numbers
        if (token.length() <= 1 || std::all_of(token.begin(), token.end(), ::isdigit)) {
            return false;
        }
        
        // Expand rare/specific terms (likely information need)
        return true;
    }
    
    std::vector<SynonymExpansion> get_expansions(const std::string& term,
                                                 const std::string& language,
                                                 float score_threshold) {
        std::vector<SynonymExpansion> expansions;
        
        // Lookup in Redis lexicon
        std::string key = "lexicon:" + language + ":" + term;
        auto lexicon_data = redis_->get(key);
        
        if (lexicon_data) {
            // Parse JSON lexicon
            auto lexicon = nlohmann::json::parse(*lexicon_data);
            
            for (const auto& exp : lexicon["expansions"]) {
                float score = exp["score"].get<float>();
                
                if (score >= score_threshold) {
                    expansions.push_back({
                        exp["term"].get<std::string>(),
                        score,
                        exp["type"].get<std::string>()
                    });
                }
            }
        }
        
        // Sort by score descending
        std::sort(expansions.begin(), expansions.end(),
                 [](const auto& a, const auto& b) { return a.score > b.score; });
        
        return expansions;
    }
    
    bool is_very_common(const std::string& token, const std::string& language) {
        // Check if token is in top-100 most frequent words
        std::string key = "common_words:" + language;
        return redis_->sismember(key, token);
    }
    
    float compute_confidence(const std::vector<Expansion>& expansions) {
        if (expansions.empty()) return 0.0f;
        
        // Average score of all expansions
        float total_score = 0.0f;
        int count = 0;
        
        for (const auto& exp : expansions) {
            for (float score : exp.scores) {
                total_score += score;
                count++;
            }
        }
        
        return count > 0 ? total_score / count : 0.0f;
    }
    
    std::vector<std::string> tokenize(const std::string& query) {
        std::vector<std::string> tokens;
        std::istringstream iss(query);
        std::string token;
        while (iss >> token) {
            tokens.push_back(token);
        }
        return tokens;
    }
    
    std::string join(const std::vector<std::string>& tokens, const std::string& delimiter) {
        std::string result;
        for (size_t i = 0; i < tokens.size(); i++) {
            result += tokens[i];
            if (i < tokens.size() - 1) {
                result += delimiter;
            }
        }
        return result;
    }
    
    sw::redis::Redis* redis_;
    float score_threshold_;
    int max_expansions_;
};
```

#### Usage Example
```cpp
// Initialize expander
sw::redis::Redis redis("redis://localhost:6379");
QueryExpander expander(&redis, /*score_threshold=*/0.7, /*max_expansions=*/3);

// Expand query
ExpansionRequest request;
request.query = "find machine learning books";
request.language = "en";
request.max_expansions = 3;
request.score_threshold = 0.75;

auto result = expander.expand(request);

std::cout << "Original: " << result.original_query << std::endl;
std::cout << "Expanded: " << result.expanded_query << std::endl;
// Original: find machine learning books
// Expanded: find search machine learning ML books publications

for (const auto& exp : result.expansions) {
    std::cout << "Expanded '" << exp.original_term << "' with:";
    for (size_t i = 0; i < exp.expanded_terms.size(); i++) {
        std::cout << " " << exp.expanded_terms[i] << " (score=" << exp.scores[i] << ")";
    }
    std::cout << std::endl;
}
```

## üìä Success Metrics
- **Recall Improvement:** ‚â•15% on tail queries
- **Precision:** <5% loss (maintain quality)
- **Latency:** <10ms per query
- **Expansion Quality:** Manual review >90% relevant
- **Expansion Limit:** ‚â§3 terms added per query
- **Coverage:** Works for 20+ languages
- **Confidence:** Average expansion score ‚â•0.7

## üéì Learning Outcomes
After completing this task, you will:
- ‚úÖ Implement query expansion strategies
- ‚úÖ Balance precision and recall in IR systems
- ‚úÖ Integrate external lexicons efficiently
- ‚úÖ Design selective expansion heuristics
- ‚úÖ Optimize text processing for low latency

---

**Expanding queries, expanding possibilities! üîç‚ú®**

