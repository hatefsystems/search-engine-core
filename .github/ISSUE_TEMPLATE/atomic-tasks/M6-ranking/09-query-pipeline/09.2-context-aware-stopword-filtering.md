# ðŸŽ¯ Task 09.2: Context-Aware Stopword Filtering

## ðŸ“… Sprint Info
- **Duration:** 4 days
- **Milestone:** M6 - Ranking & Query Pipeline
- **Priority:** P0 (Critical Path)
- **Depends On:** Task 09.1 (Language Detection Routing) âœ…
- **Blocks:** Task 09.4 (Multi-Stage Retrieval)
- **Assignee:** TBD

## ðŸŽ¬ What You'll Build
Implement intelligent context-aware stopword filtering that understands query structure and intent. Never breaks single-word queries, preserves entity names, handles quoted phrases, and provides multi-stage fallback (filtered â†’ original) for maximum recall.

## ðŸ“‹ Daily Breakdown

### Day 1: Query Analysis & Rules Engine
- [ ] Implement single-token query detection (never filter)
- [ ] Build quoted phrase detector ("exact match")
- [ ] Add entity name pattern recognition
- [ ] Create query structure analyzer
- [ ] Implement decision rules engine
- [ ] Add confidence scoring for filtering decisions
- [ ] Build debug mode with decision traces
- [ ] Unit tests for query patterns (50+ cases)

### Day 2: Stopword Decision Logic
- [ ] Load stopword lexicons from Redis (multi-language)
- [ ] Implement conservative filtering strategy
- [ ] Add context-aware rules (when to filter vs preserve)
- [ ] Build fallback decision tree
- [ ] Handle mixed-language queries
- [ ] Add whitelist for important stopwords in entity names
- [ ] Test on real query logs (if available)
- [ ] Performance optimization: <5ms per query

### Day 3: Multi-Stage Fallback Strategy
- [ ] Implement two-pass retrieval (filtered first, original fallback)
- [ ] Build result quality detector (when to trigger fallback)
- [ ] Add automatic fallback threshold tuning
- [ ] Implement result merging and deduplication
- [ ] Track fallback metrics (how often triggered)
- [ ] Test recall improvement on low-result queries
- [ ] Document fallback decision logic

### Day 4: Integration & Testing
- [ ] Integrate with query pipeline (Task 09.1)
- [ ] Add comprehensive test suite (100+ query patterns)
- [ ] Edge case testing (single words, quotes, entities, mixed languages)
- [ ] Performance benchmarking (<5ms latency)
- [ ] A/B test configuration for gradual rollout
- [ ] Monitoring dashboard and alerts
- [ ] Documentation and examples

## âœ… Acceptance Criteria
- [ ] Never filters single-word queries (100% pass rate)
- [ ] Preserves quoted phrases exactly (100% pass rate)
- [ ] Entity name detection accuracy â‰¥95%
- [ ] Multi-stage fallback improves recall by â‰¥15%
- [ ] Filtering adds <5ms latency to query processing
- [ ] Works across 20+ languages automatically
- [ ] False filtering rate <2% (precision)
- [ ] Debug mode shows clear decision reasoning

## ðŸ§ª Testing Checklist
- [ ] Unit tests for query analyzers (50+ test cases)
- [ ] Decision rules tests (40+ scenarios)
- [ ] Single-word query tests (never filter)
- [ ] Quoted phrase tests (preserve exactly)
- [ ] Entity detection tests (names, brands, places)
- [ ] Multi-language tests (10+ languages)
- [ ] Fallback strategy tests (recall improvement)
- [ ] Performance benchmarks (<5ms)
- [ ] Edge case tests (empty query, symbols, numbers)

## ðŸŽ‰ Celebration Criteria (Definition of Done)
âœ… **Demo Ready:** Show smart filtering on diverse query types with debug traces
âœ… **Metric Met:** 95% accuracy, 15% recall improvement, <5ms latency
âœ… **Integration:** Seamlessly integrated into query pipeline
âœ… **Reliability:** Zero query breakage in production testing

**ðŸŽŠ Celebration Moment:** Intelligent filtering that never loses user intent!

## ðŸ“¦ Deliverables
- `src/pipeline/ContextAwareStopwordFilter.h` (C++ header, 100 lines)
- `src/pipeline/ContextAwareStopwordFilter.cpp` (C++ impl, 400-500 lines)
- `src/pipeline/QueryAnalyzer.h` (C++ header, 80 lines)
- `src/pipeline/QueryAnalyzer.cpp` (C++ impl, 300 lines)
- `tests/test_stopword_filtering.cpp` (100+ test cases)
- `tests/test_query_analyzer.cpp` (50+ test cases)
- `docs/stopword-filtering-guide.md`
- `monitoring/stopword_filtering_dashboard.json`

## ðŸ”— Dependencies & Integration

### Input
```cpp
struct QueryAnalysisRequest {
    std::string query;          // Raw query
    std::string language;       // Detected language
    bool debug_mode;            // Show decision traces
};
```

### Output
```cpp
struct StopwordFilteringResult {
    std::string original_query;
    std::string filtered_query;
    std::vector<std::string> removed_stopwords;
    bool should_filter;         // Decision: filter or not
    float confidence;           // Confidence in decision
    std::string decision_reason; // Human-readable explanation
    
    struct QueryStructure {
        bool is_single_word;
        bool has_quoted_phrases;
        bool is_entity_name;
        int token_count;
        std::vector<std::string> preserved_tokens;
    } structure;
};
```

### Decision Rules (Examples)
```cpp
// Rule 1: Never filter single-word queries
if (tokens.size() == 1) {
    return FilterDecision::PRESERVE_ALL;
}

// Rule 2: Preserve quoted phrases exactly
if (has_quoted_phrase) {
    return FilterDecision::PRESERVE_QUOTED;
}

// Rule 3: Entity name detection (capital letters, proper nouns)
if (is_entity_name(query)) {
    return FilterDecision::PRESERVE_ALL;
}

// Rule 4: Common navigational queries (brand + generic term)
if (is_navigational_pattern(query)) {
    return FilterDecision::PRESERVE_ALL;
}

// Rule 5: When uncertain, don't filter (conservative)
if (confidence < CONFIDENCE_THRESHOLD) {
    return FilterDecision::PRESERVE_ALL;
}
```

### External Dependencies
- Redis (stopword lexicons)
- C++ standard library (string processing, regex)
- Optional: NER library for entity detection

## ðŸš€ Next Steps
âž¡ï¸ **Task 09.4: Multi-Stage Retrieval Pipeline** (4 days)
- Uses filtered and original queries for two-pass retrieval
- Merges results intelligently based on quality signals

âž¡ï¸ **Task 09.5: Hybrid Spell Correction Pipeline** (3 days)
- Complements stopword filtering with typo detection
- Preserves intentional non-standard spellings

## ðŸ’¡ Tips & Resources

### Common Pitfalls
- âš ï¸ **Over-filtering**: Aggressive filtering breaks entity queries
- âš ï¸ **Under-filtering**: Too conservative loses ranking precision
- âš ï¸ **Language assumptions**: Stopwords vary across languages
- âš ï¸ **Quote handling**: Preserve spacing and punctuation exactly
- âš ï¸ **Performance**: Regex can be slow, optimize patterns

### Helpful Resources
- [Stopword Lists by Language](https://github.com/stopwords-iso/stopwords-iso)
- [Named Entity Recognition Techniques](https://en.wikipedia.org/wiki/Named-entity_recognition)
- [Query Understanding in Search](https://eugeneyan.com/writing/search-query-matching/)
- [C++ Regex Performance](https://www.boost.org/doc/libs/1_78_0/libs/regex/)

### Example Code

#### Query Analyzer
```cpp
#include <regex>
#include <vector>
#include <string>

class QueryAnalyzer {
public:
    struct QueryStructure {
        bool is_single_word;
        bool has_quoted_phrases;
        bool is_entity_name;
        int token_count;
        std::vector<std::string> tokens;
        std::vector<std::pair<int, int>> quoted_ranges;
    };
    
    QueryStructure analyze(const std::string& query) {
        QueryStructure structure;
        
        // Tokenize
        structure.tokens = tokenize(query);
        structure.token_count = structure.tokens.size();
        structure.is_single_word = (structure.token_count == 1);
        
        // Detect quoted phrases
        structure.has_quoted_phrases = detect_quoted_phrases(query, structure.quoted_ranges);
        
        // Detect entity names (simple heuristic: starts with capital)
        structure.is_entity_name = detect_entity_name(query);
        
        return structure;
    }
    
private:
    std::vector<std::string> tokenize(const std::string& query) {
        // Simple whitespace tokenization
        std::vector<std::string> tokens;
        std::istringstream iss(query);
        std::string token;
        while (iss >> token) {
            tokens.push_back(token);
        }
        return tokens;
    }
    
    bool detect_quoted_phrases(const std::string& query, 
                               std::vector<std::pair<int, int>>& ranges) {
        // Find text within quotes
        std::regex quote_pattern(R"("([^"]+)")");
        std::smatch matches;
        
        std::string::const_iterator searchStart(query.cbegin());
        while (std::regex_search(searchStart, query.cend(), matches, quote_pattern)) {
            int start = std::distance(query.cbegin(), matches[0].first);
            int end = std::distance(query.cbegin(), matches[0].second);
            ranges.push_back({start, end});
            searchStart = matches.suffix().first;
        }
        
        return !ranges.empty();
    }
    
    bool detect_entity_name(const std::string& query) {
        // Simple heuristic: Check if query starts with capital letter
        // More sophisticated: Use NER or pattern matching
        if (query.empty()) return false;
        
        // Check if most words start with capital
        auto tokens = tokenize(query);
        int capital_count = 0;
        for (const auto& token : tokens) {
            if (!token.empty() && std::isupper(token[0])) {
                capital_count++;
            }
        }
        
        // If >50% tokens capitalized, likely entity name
        return (capital_count > tokens.size() / 2);
    }
};
```

#### Context-Aware Stopword Filter
```cpp
class ContextAwareStopwordFilter {
public:
    ContextAwareStopwordFilter(RedisClient* redis) : redis_(redis) {
        load_stopword_lexicons();
    }
    
    StopwordFilteringResult filter(const QueryAnalysisRequest& request) {
        StopwordFilteringResult result;
        result.original_query = request.query;
        
        // Step 1: Analyze query structure
        auto structure = analyzer_.analyze(request.query);
        result.structure = structure;
        
        // Step 2: Make filtering decision
        auto decision = make_decision(structure, request.language);
        result.should_filter = decision.should_filter;
        result.confidence = decision.confidence;
        result.decision_reason = decision.reason;
        
        // Step 3: Apply filtering if decided
        if (result.should_filter) {
            result.filtered_query = apply_filtering(
                request.query, 
                structure, 
                request.language,
                result.removed_stopwords
            );
        } else {
            result.filtered_query = request.query;
        }
        
        // Debug mode: add detailed traces
        if (request.debug_mode) {
            result.debug_trace = generate_debug_trace(structure, decision);
        }
        
        return result;
    }
    
private:
    struct FilterDecision {
        bool should_filter;
        float confidence;
        std::string reason;
    };
    
    FilterDecision make_decision(const QueryStructure& structure, 
                                 const std::string& language) {
        // Rule 1: Never filter single-word queries
        if (structure.is_single_word) {
            return {false, 1.0, "Single-word query: never filter"};
        }
        
        // Rule 2: Preserve quoted phrases
        if (structure.has_quoted_phrases) {
            return {false, 1.0, "Contains quoted phrase: preserve exactly"};
        }
        
        // Rule 3: Preserve entity names
        if (structure.is_entity_name) {
            return {false, 0.9, "Detected entity name: preserve all tokens"};
        }
        
        // Rule 4: Filter if â‰¥3 tokens and some are stopwords
        if (structure.token_count >= 3) {
            int stopword_count = count_stopwords(structure.tokens, language);
            if (stopword_count > 0) {
                float stopword_ratio = static_cast<float>(stopword_count) / structure.token_count;
                if (stopword_ratio < 0.5) {  // Don't over-filter
                    return {true, 0.8, "Multi-token query with stopwords: safe to filter"};
                }
            }
        }
        
        // Default: Conservative - don't filter
        return {false, 0.5, "Uncertain: conservative strategy is to preserve"};
    }
    
    std::string apply_filtering(const std::string& query,
                               const QueryStructure& structure,
                               const std::string& language,
                               std::vector<std::string>& removed) {
        std::vector<std::string> kept_tokens;
        
        for (const auto& token : structure.tokens) {
            if (is_stopword(token, language)) {
                removed.push_back(token);
            } else {
                kept_tokens.push_back(token);
            }
        }
        
        // Join tokens back
        std::string filtered;
        for (size_t i = 0; i < kept_tokens.size(); i++) {
            filtered += kept_tokens[i];
            if (i < kept_tokens.size() - 1) {
                filtered += " ";
            }
        }
        
        return filtered;
    }
    
    bool is_stopword(const std::string& token, const std::string& language) {
        // Check stopword lexicon from Redis
        auto key = "stopword:" + language + ":" + token;
        return redis_->exists(key);
    }
    
    void load_stopword_lexicons() {
        // Load from Redis on startup
        // Cache in memory for fast lookups
    }
    
    QueryAnalyzer analyzer_;
    RedisClient* redis_;
    std::unordered_map<std::string, std::unordered_set<std::string>> stopword_cache_;
};
```

## ðŸ“Š Success Metrics
- **Accuracy:** 95% correct filtering decisions
- **Recall Improvement:** â‰¥15% with multi-stage fallback
- **Precision:** <2% false filtering rate
- **Latency:** <5ms per query
- **Single-Word Protection:** 100% never filtered
- **Entity Preservation:** â‰¥95% accuracy
- **Multi-Language:** Works for 20+ languages

## ðŸŽ“ Learning Outcomes
After completing this task, you will:
- âœ… Build intelligent rule-based NLP systems
- âœ… Handle edge cases in query processing
- âœ… Design conservative fallback strategies
- âœ… Implement fast C++ text processing
- âœ… Balance precision and recall in ranking

---

**Smart filtering that understands context! ðŸ§ ðŸ”**

