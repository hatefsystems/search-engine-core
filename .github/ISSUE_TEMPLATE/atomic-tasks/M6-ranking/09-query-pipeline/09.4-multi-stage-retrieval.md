# ðŸŽ¯ Task 09.4: Multi-Stage Retrieval with Fallback

## ðŸ“… Sprint Info
- **Duration:** 4 days
- **Milestone:** M6 - Ranking & Query Pipeline
- **Priority:** P0 (Critical Path)
- **Depends On:** Task 09.2 (Stopword Filtering) âœ…, Task 09.3 (Query Expansion) âœ…
- **Blocks:** Task 09.7 (Feature Gathering)
- **Assignee:** TBD

## ðŸŽ¬ What You'll Build
Implement intelligent multi-stage retrieval combining BM25 and n-gram fallback across three query variants: (1) filtered+expanded, (2) original+expanded, (3) n-gram fallback. Merge results intelligently to maximize recall without sacrificing precision.

## ðŸ“‹ Daily Breakdown

### Day 1: Retrieval Pipeline Architecture
- [ ] Design three-stage retrieval strategy
- [ ] Implement BM25 retrieval (filtered query)
- [ ] Implement BM25 retrieval (original query fallback)
- [ ] Implement n-gram retrieval (for rare/misspelled terms)
- [ ] Build result quality detector (when to trigger fallback)
- [ ] Add configurable thresholds for stage triggers
- [ ] Unit tests for each retrieval stage (30+ cases)

### Day 2: Result Merging & Deduplication
- [ ] Implement intelligent result merging
- [ ] Build deduplication by document ID
- [ ] Add score normalization across stages
- [ ] Implement stage-aware ranking (prefer early stages)
- [ ] Handle result diversity in merging
- [ ] Test merge quality on diverse queries
- [ ] Performance optimization

### Day 3: Fallback Logic & Quality Detection
- [ ] Implement fallback trigger conditions
- [ ] Build result quality scorer (when results are "good enough")
- [ ] Add adaptive threshold tuning
- [ ] Track fallback metrics (how often triggered)
- [ ] Test on low-result and zero-result queries
- [ ] Document fallback decision logic
- [ ] Add monitoring and alerts

### Day 4: Integration & Testing
- [ ] Integrate with query pipeline (Tasks 09.2, 09.3)
- [ ] Comprehensive end-to-end tests (100+ query scenarios)
- [ ] Performance benchmarking (target P95 <80ms)
- [ ] Recall improvement validation (â‰¥25% vs single-stage)
- [ ] Precision validation (no degradation)
- [ ] Multi-language tests (10+ languages)
- [ ] Documentation and examples

## âœ… Acceptance Criteria
- [ ] Three-stage retrieval: filtered â†’ original â†’ n-gram
- [ ] Recall improvement: â‰¥25% vs single-stage BM25
- [ ] Precision maintained: <3% degradation
- [ ] P95 latency: â‰¤80ms for top-200 retrieval
- [ ] Intelligent fallback: only trigger when needed (â‰¤30% of queries)
- [ ] Deduplication: no duplicate documents in results
- [ ] Result quality: prefer early stage results when possible
- [ ] Works across 20+ languages automatically

## ðŸ§ª Testing Checklist
- [ ] Unit tests for each retrieval stage (30+ test cases)
- [ ] Merge logic tests (40+ scenarios)
- [ ] Fallback trigger tests (20+ conditions)
- [ ] Deduplication tests (edge cases)
- [ ] Recall improvement tests (compare vs baseline)
- [ ] Precision tests (no junk results)
- [ ] Performance benchmarks (P95 <80ms)
- [ ] Multi-language tests (10+ languages)
- [ ] Edge cases (zero results, single result, duplicates)

## ðŸŽ‰ Celebration Criteria (Definition of Done)
âœ… **Demo Ready:** Show recall improvement on diverse query types
âœ… **Metric Met:** 25% recall gain, <3% precision loss, <80ms P95 latency
âœ… **Integration:** Seamlessly integrated into end-to-end pipeline
âœ… **Reliability:** 7-day production testing with no issues

**ðŸŽŠ Celebration Moment:** Never miss relevant results again!

## ðŸ“¦ Deliverables
- `src/pipeline/MultiStageRetriever.h` (C++ header, 120 lines)
- `src/pipeline/MultiStageRetriever.cpp` (C++ impl, 500-600 lines)
- `src/pipeline/ResultMerger.cpp` (merging logic, 300 lines)
- `src/pipeline/FallbackDetector.cpp` (fallback logic, 200 lines)
- `tests/test_multi_stage_retrieval.cpp` (100+ test cases)
- `docs/multi-stage-retrieval-guide.md`
- `monitoring/retrieval_stages_dashboard.json`

## ðŸ”— Dependencies & Integration

### Input
```cpp
struct RetrievalRequest {
    std::string original_query;
    std::string filtered_query;      // From Task 09.2
    std::string expanded_query;      // From Task 09.3
    std::string language;
    int top_k;                       // Results per stage
    bool enable_fallback;
};
```

### Output
```cpp
struct RetrievalResult {
    std::vector<ScoredDocument> documents;
    
    struct StageStat {
        std::string stage_name;
        int results_count;
        float avg_score;
        float latency_ms;
    };
    std::vector<StageStat> stage_stats;
    
    bool fallback_triggered;
    std::string fallback_reason;
    int total_candidates;
    int dedup_count;
};

struct ScoredDocument {
    std::string doc_id;
    float score;
    std::string source_stage;  // "stage1" | "stage2" | "stage3"
    int rank_in_stage;
};
```

### Three-Stage Retrieval Strategy
```cpp
// Stage 1: BM25 with filtered+expanded query (highest precision)
auto stage1_results = bm25_retrieve(
    filtered_query + " " + expanded_query, 
    top_k=200
);

// Stage 2: BM25 with original+expanded query (fallback if Stage 1 insufficient)
if (result_quality(stage1_results) < QUALITY_THRESHOLD) {
    auto stage2_results = bm25_retrieve(
        original_query + " " + expanded_query,
        top_k=100
    );
    stage1_results = merge_results(stage1_results, stage2_results);
}

// Stage 3: N-gram fallback (for rare terms, typos, low results)
if (result_quality(stage1_results) < QUALITY_THRESHOLD_LOW) {
    auto stage3_results = ngram_retrieve(
        original_query,
        top_k=100,
        ngram_size=3-5
    );
    stage1_results = merge_results(stage1_results, stage3_results);
}

return deduplicate_and_rank(stage1_results);
```

### External Dependencies
- RedisSearch or custom BM25 implementation
- N-gram index (from Task 02.2)
- C++ standard library (containers, algorithms)

## ðŸš€ Next Steps
âž¡ï¸ **Task 09.7: Feature Gathering Pipeline** (3 days)
- Gathers features for retrieved candidates
- Prepares for re-ranking with FinalScore

âž¡ï¸ **Task 08.2: Feature Fusion & Re-ranking** (4 days)
- Re-ranks multi-stage candidates with combined signals
- Applies FinalScore formula

## ðŸ’¡ Tips & Resources

### Common Pitfalls
- âš ï¸ **Over-fallback**: Triggering fallback too often reduces precision
- âš ï¸ **Under-fallback**: Not triggering enough misses recall gains
- âš ï¸ **Duplicate results**: Merge without deduplication confuses users
- âš ï¸ **Score incompatibility**: Different stages have different score ranges
- âš ï¸ **Performance**: Running all stages sequentially is too slow

### Helpful Resources
- [Multi-Stage Retrieval in Elasticsearch](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)
- [Query Rewriting Strategies](https://www.searchblox.com/query-rewriting-techniques)
- [BM25 Algorithm](https://en.wikipedia.org/wiki/Okapi_BM25)
- [N-gram Indexing](https://nlp.stanford.edu/IR-book/html/htmledition/n-gram-indexes-1.html)

### Example Code

#### Multi-Stage Retriever
```cpp
#include <vector>
#include <string>
#include <unordered_set>
#include <algorithm>

class MultiStageRetriever {
public:
    MultiStageRetriever(BM25Engine* bm25, NGramEngine* ngram)
        : bm25_(bm25), ngram_(ngram) {}
    
    RetrievalResult retrieve(const RetrievalRequest& request) {
        RetrievalResult result;
        auto start_time = std::chrono::steady_clock::now();
        
        // Stage 1: BM25 with filtered+expanded query
        auto stage1_query = request.filtered_query;
        if (!request.expanded_query.empty()) {
            stage1_query += " " + request.expanded_query;
        }
        
        auto stage1_results = bm25_->retrieve(stage1_query, request.top_k);
        result.stage_stats.push_back({
            "stage1_filtered_expanded",
            static_cast<int>(stage1_results.size()),
            compute_avg_score(stage1_results),
            elapsed_ms(start_time)
        });
        
        // Check if Stage 1 quality is sufficient
        float stage1_quality = compute_result_quality(stage1_results);
        
        if (request.enable_fallback && stage1_quality < QUALITY_THRESHOLD_MEDIUM) {
            // Stage 2: BM25 with original+expanded query
            start_time = std::chrono::steady_clock::now();
            
            auto stage2_query = request.original_query;
            if (!request.expanded_query.empty()) {
                stage2_query += " " + request.expanded_query;
            }
            
            auto stage2_results = bm25_->retrieve(stage2_query, request.top_k / 2);
            result.stage_stats.push_back({
                "stage2_original_expanded",
                static_cast<int>(stage2_results.size()),
                compute_avg_score(stage2_results),
                elapsed_ms(start_time)
            });
            
            // Merge Stage 1 and Stage 2 results
            stage1_results = merge_results(stage1_results, stage2_results, "stage2");
            result.fallback_triggered = true;
            result.fallback_reason = "Stage 1 quality insufficient";
        }
        
        // Check if we need n-gram fallback
        float combined_quality = compute_result_quality(stage1_results);
        
        if (request.enable_fallback && combined_quality < QUALITY_THRESHOLD_LOW) {
            // Stage 3: N-gram fallback
            start_time = std::chrono::steady_clock::now();
            
            auto stage3_results = ngram_->retrieve(request.original_query, request.top_k / 2);
            result.stage_stats.push_back({
                "stage3_ngram_fallback",
                static_cast<int>(stage3_results.size()),
                compute_avg_score(stage3_results),
                elapsed_ms(start_time)
            });
            
            // Merge with Stage 3 results
            stage1_results = merge_results(stage1_results, stage3_results, "stage3");
            result.fallback_triggered = true;
            result.fallback_reason = "N-gram fallback for low results";
        }
        
        // Deduplicate and finalize
        result.documents = deduplicate_and_rank(stage1_results);
        result.total_candidates = stage1_results.size();
        result.dedup_count = stage1_results.size() - result.documents.size();
        
        return result;
    }
    
private:
    std::vector<ScoredDocument> merge_results(
        const std::vector<ScoredDocument>& primary,
        const std::vector<ScoredDocument>& fallback,
        const std::string& fallback_stage) {
        
        std::vector<ScoredDocument> merged = primary;
        
        // Add fallback results that aren't already in primary
        std::unordered_set<std::string> seen_docs;
        for (const auto& doc : primary) {
            seen_docs.insert(doc.doc_id);
        }
        
        for (auto doc : fallback) {
            if (seen_docs.find(doc.doc_id) == seen_docs.end()) {
                // Normalize and penalize fallback scores slightly
                doc.score *= 0.9;  // 10% penalty for fallback results
                doc.source_stage = fallback_stage;
                merged.push_back(doc);
                seen_docs.insert(doc.doc_id);
            }
        }
        
        // Re-sort by score
        std::sort(merged.begin(), merged.end(),
                 [](const auto& a, const auto& b) { return a.score > b.score; });
        
        return merged;
    }
    
    std::vector<ScoredDocument> deduplicate_and_rank(
        const std::vector<ScoredDocument>& candidates) {
        
        std::vector<ScoredDocument> deduped;
        std::unordered_set<std::string> seen;
        
        for (const auto& doc : candidates) {
            if (seen.find(doc.doc_id) == seen.end()) {
                deduped.push_back(doc);
                seen.insert(doc.doc_id);
            }
        }
        
        // Final ranking: prefer early stage results with tie-breaking
        std::sort(deduped.begin(), deduped.end(),
                 [](const auto& a, const auto& b) {
                     if (std::abs(a.score - b.score) < 0.01) {
                         // Tie: prefer earlier stage
                         return a.source_stage < b.source_stage;
                     }
                     return a.score > b.score;
                 });
        
        return deduped;
    }
    
    float compute_result_quality(const std::vector<ScoredDocument>& results) {
        if (results.empty()) return 0.0f;
        
        // Quality heuristics:
        // 1. Number of results (more is better, up to a point)
        // 2. Score distribution (high scores indicate good matches)
        // 3. Score variance (low variance may indicate poor matches)
        
        float count_score = std::min(results.size() / 50.0f, 1.0f);
        float avg_score = compute_avg_score(results);
        float top_score = results.empty() ? 0.0f : results[0].score;
        
        return 0.3f * count_score + 0.4f * avg_score + 0.3f * (top_score / 100.0f);
    }
    
    float compute_avg_score(const std::vector<ScoredDocument>& results) {
        if (results.empty()) return 0.0f;
        
        float sum = 0.0f;
        for (const auto& doc : results) {
            sum += doc.score;
        }
        return sum / results.size();
    }
    
    float elapsed_ms(std::chrono::steady_clock::time_point start) {
        auto end = std::chrono::steady_clock::now();
        return std::chrono::duration<float, std::milli>(end - start).count();
    }
    
    BM25Engine* bm25_;
    NGramEngine* ngram_;
    
    // Quality thresholds
    const float QUALITY_THRESHOLD_MEDIUM = 0.6f;
    const float QUALITY_THRESHOLD_LOW = 0.3f;
};
```

## ðŸ“Š Success Metrics
- **Recall Improvement:** â‰¥25% vs single-stage BM25
- **Precision:** <3% degradation from baseline
- **Latency:** P95 â‰¤80ms for top-200 retrieval
- **Fallback Rate:** 20-30% of queries (adaptive)
- **Deduplication:** 100% of duplicates removed
- **Stage Efficiency:** Stage 1 sufficient for â‰¥70% of queries
- **Multi-Language:** Works for 20+ languages

## ðŸŽ“ Learning Outcomes
After completing this task, you will:
- âœ… Design multi-stage retrieval pipelines
- âœ… Implement intelligent fallback strategies
- âœ… Merge and deduplicate search results
- âœ… Balance precision and recall trade-offs
- âœ… Optimize IR systems for both quality and speed

---

**Three stages to perfection! ðŸŽ¯ðŸ”ðŸš€**

