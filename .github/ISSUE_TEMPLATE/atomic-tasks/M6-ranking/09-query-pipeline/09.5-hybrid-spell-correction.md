# ðŸŽ¯ Task 09.5: Hybrid Spell Correction Pipeline

## ðŸ“… Sprint Info
- **Duration:** 3 days
- **Milestone:** M6 - Ranking & Query Pipeline
- **Priority:** P1
- **Depends On:** Task 05.6 (Spell Correction Models) âœ…
- **Blocks:** Task 09.6 (Query Rewriting)
- **Assignee:** TBD

## ðŸŽ¬ What You'll Build
Implement three-stage hybrid spell correction: (1) edit distance candidates (<1ms), (2) corpus frequency validation (2-3ms), (3) embedding semantic validation (5-8ms). Provide "Did you mean?" suggestions and auto-correction for high-confidence cases.

## ðŸ“‹ Daily Breakdown

### Day 1: Three-Stage Pipeline Implementation
- [ ] Implement Stage 1: Edit distance candidate generation
- [ ] Implement Stage 2: Frequency-based filtering
- [ ] Implement Stage 3: Embedding-based semantic validation
- [ ] Build confidence scoring algorithm
- [ ] Add adaptive staging (skip expensive stages when confident)
- [ ] Performance optimization: Stage 1 <1ms, Stage 2 2-3ms, Stage 3 5-8ms
- [ ] Unit tests for each stage (50+ test cases)

### Day 2: Suggestion API & Auto-Correction
- [ ] Build "Did you mean?" suggestion API
- [ ] Implement auto-correction threshold (confidence >0.9)
- [ ] Add correction ranking (multiple candidates)
- [ ] Build user preference learning (optional)
- [ ] Test on real typo datasets
- [ ] False positive prevention (valid words flagged as typos)
- [ ] Multi-language support (10+ languages)

### Day 3: Integration & Testing
- [ ] Integrate with query pipeline
- [ ] Add comprehensive test suite (100+ typo examples)
- [ ] Performance benchmarking (latency per stage)
- [ ] Precision/recall validation (â‰¥92% accuracy)
- [ ] A/B test configuration
- [ ] Monitoring dashboard
- [ ] Documentation and examples

## âœ… Acceptance Criteria
- [ ] Typo detection accuracy: â‰¥92%
- [ ] Spell suggestion precision: â‰¥95% (minimal false positives)
- [ ] Auto-correction applied only for confidence >0.9
- [ ] Stage 1 latency: <1ms
- [ ] Stage 2 latency: 2-3ms additional
- [ ] Stage 3 latency: 5-8ms additional (only when needed)
- [ ] Total pipeline latency: <10ms average
- [ ] Works across 20+ languages automatically

## ðŸ§ª Testing Checklist
- [ ] Edit distance tests (30+ cases)
- [ ] Frequency validation tests (40+ cases)
- [ ] Semantic validation tests (50+ cases)
- [ ] Confidence scoring tests (30+ cases)
- [ ] False positive tests (valid words)
- [ ] Multi-language tests (10+ languages)
- [ ] Performance benchmarks (per-stage latency)
- [ ] End-to-end integration tests

## ðŸŽ‰ Celebration Criteria (Definition of Done)
âœ… **Demo Ready:** Show spell correction on diverse typos with confidence scores
âœ… **Metric Met:** 92% accuracy, 95% precision, <10ms average latency
âœ… **Integration:** Seamlessly integrated into query pipeline
âœ… **Quality:** User testing confirms helpful corrections

**ðŸŽŠ Celebration Moment:** Typos are no longer a barrier to search!

## ðŸ“¦ Deliverables
- `src/pipeline/HybridSpellCorrector.h` (C++ header, 100 lines)
- `src/pipeline/HybridSpellCorrector.cpp` (C++ impl, 500 lines)
- `src/pipeline/EditDistanceCalculator.cpp` (Stage 1, 200 lines)
- `src/pipeline/FrequencyValidator.cpp` (Stage 2, 150 lines)
- `src/pipeline/SemanticValidator.cpp` (Stage 3, 200 lines)
- `tests/test_spell_correction_pipeline.cpp` (100+ test cases)
- `docs/spell-correction-pipeline-guide.md`

## ðŸ”— Dependencies & Integration

### Input
```cpp
struct SpellCheckRequest {
    std::string query;
    std::string language;
    bool enable_auto_correct;
    float confidence_threshold;  // Default: 0.9
};
```

### Output
```cpp
struct SpellCheckResult {
    std::string original_query;
    std::string corrected_query;    // Only if auto_correct enabled
    bool has_typos;
    std::vector<Correction> corrections;
    
    struct Correction {
        std::string original_token;
        std::vector<Candidate> candidates;
        std::string selected_correction;  // If auto-corrected
        float confidence;
    };
    
    struct Candidate {
        std::string word;
        float edit_distance_score;
        float frequency_score;
        float semantic_score;
        float combined_confidence;
    };
    
    struct StageMetrics {
        float stage1_latency_ms;
        float stage2_latency_ms;
        float stage3_latency_ms;
        int stage1_candidates;
        int stage2_candidates;
        int stage3_candidates;
    } metrics;
};
```

### Three-Stage Pipeline
```cpp
// Stage 1: Edit Distance (<1ms)
auto candidates = generate_edit_distance_candidates(token, max_distance=2);
// Returns: 10-50 candidates within edit distance 2

// Stage 2: Frequency Validation (2-3ms)
auto valid_candidates = filter_by_corpus_frequency(candidates, min_freq=100);
// Returns: 5-10 candidates that exist in vocabulary

// Stage 3: Semantic Validation (5-8ms, only if needed)
if (valid_candidates.size() > 3 || max_confidence < 0.8) {
    ranked_candidates = rank_by_semantic_similarity(query_context, valid_candidates);
}
// Returns: Top 3 candidates ranked by semantic coherence
```

## ðŸ’¡ Example Code

```cpp
class HybridSpellCorrector {
public:
    HybridSpellCorrector(VocabularyStore* vocab, EmbeddingClient* embeddings)
        : vocab_(vocab), embeddings_(embeddings) {}
    
    SpellCheckResult check_and_correct(const SpellCheckRequest& request) {
        SpellCheckResult result;
        result.original_query = request.query;
        
        auto tokens = tokenize(request.query);
        
        for (const auto& token : tokens) {
            auto correction = correct_token(token, request);
            
            if (!correction.candidates.empty()) {
                result.has_typos = true;
                result.corrections.push_back(correction);
            }
        }
        
        // Auto-correct if confidence is high
        if (request.enable_auto_correct) {
            result.corrected_query = apply_corrections(result.corrections, request.confidence_threshold);
        }
        
        return result;
    }
    
private:
    Correction correct_token(const std::string& token, const SpellCheckRequest& request) {
        Correction correction;
        correction.original_token = token;
        
        auto start = std::chrono::steady_clock::now();
        
        // Stage 1: Edit distance candidates
        auto stage1_candidates = edit_distance_generator_.generate(token, 2);
        correction.metrics.stage1_latency_ms = elapsed_ms(start);
        correction.metrics.stage1_candidates = stage1_candidates.size();
        
        if (stage1_candidates.empty()) {
            return correction;  // No typo detected
        }
        
        start = std::chrono::steady_clock::now();
        
        // Stage 2: Frequency validation
        auto stage2_candidates = frequency_validator_.filter(stage1_candidates, request.language);
        correction.metrics.stage2_latency_ms = elapsed_ms(start);
        correction.metrics.stage2_candidates = stage2_candidates.size();
        
        if (stage2_candidates.empty()) {
            return correction;  // No valid corrections found
        }
        
        // Decide if we need Stage 3
        float max_conf = compute_max_confidence(stage2_candidates);
        
        if (stage2_candidates.size() > 3 || max_conf < 0.8) {
            start = std::chrono::steady_clock::now();
            
            // Stage 3: Semantic validation
            correction.candidates = semantic_validator_.rank(token, stage2_candidates, request.query);
            correction.metrics.stage3_latency_ms = elapsed_ms(start);
            correction.metrics.stage3_candidates = correction.candidates.size();
        } else {
            // Skip Stage 3, use Stage 2 results
            correction.candidates = stage2_candidates;
        }
        
        // Select best correction
        if (!correction.candidates.empty()) {
            correction.selected_correction = correction.candidates[0].word;
            correction.confidence = correction.candidates[0].combined_confidence;
        }
        
        return correction;
    }
    
    std::string apply_corrections(const std::vector<Correction>& corrections, 
                                  float confidence_threshold) {
        std::string corrected = original_query;
        
        for (const auto& corr : corrections) {
            if (corr.confidence >= confidence_threshold && !corr.selected_correction.empty()) {
                // Replace token with correction
                corrected = replace_token(corrected, corr.original_token, corr.selected_correction);
            }
        }
        
        return corrected;
    }
    
    VocabularyStore* vocab_;
    EmbeddingClient* embeddings_;
    EditDistanceGenerator edit_distance_generator_;
    FrequencyValidator frequency_validator_;
    SemanticValidator semantic_validator_;
};
```

## ðŸ“Š Success Metrics
- **Accuracy:** â‰¥92% typo detection
- **Precision:** â‰¥95% suggestion quality
- **Latency:** Stage 1 <1ms, Stage 2 +2-3ms, Stage 3 +5-8ms
- **Confidence:** Auto-correction only for >0.9 confidence
- **False Positives:** <5% valid words flagged
- **Coverage:** 20+ languages supported

## ðŸŽ“ Learning Outcomes
- âœ… Design multi-stage ML pipelines
- âœ… Optimize latency with adaptive staging
- âœ… Balance precision and recall in NLP
- âœ… Build production spell correction systems
- âœ… Handle multilingual text processing

---

**Perfect spelling, every time! âœ¨ðŸ“**

