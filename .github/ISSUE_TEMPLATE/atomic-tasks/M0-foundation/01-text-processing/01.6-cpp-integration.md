# üéØ Task 01.6: C++ Integration

## üìÖ Sprint Info
- **Duration:** 4 days
- **Milestone:** M0 - Foundation  
- **Priority:** P0 (Critical Path)
- **Depends On:** Tasks 01.1-01.4 ‚úÖ
- **Blocks:** Task 02.1 (BM25 Implementation)
- **Assignee:** TBD

## üé¨ What You'll Build
Build high-performance C++ wrapper for Python text processing pipeline using pybind11. Seamlessly integrates with existing uWebSockets C++ server.

## üìã Daily Breakdown

### Day 1: pybind11 Setup & Basic Wrapper
- [ ] Install pybind11 dependencies
- [ ] Create C++ wrapper project structure
- [ ] Implement basic Python ‚Üí C++ bridge
- [ ] Expose normalize() function to C++
- [ ] Build system setup (CMake integration)

### Day 2: Complete API Wrapper
- [ ] Wrap language detection API
- [ ] Wrap script processing API
- [ ] Wrap stopword checking API
- [ ] Implement LanguageInfo struct in C++
- [ ] Add error handling and exceptions

### Day 3: Performance Optimization
- [ ] Benchmark C++ vs pure Python
- [ ] Add caching layer for hot paths
- [ ] Thread safety for concurrent requests
- [ ] Memory management optimization
- [ ] Target: <5ms latency overhead

### Day 4: Testing & Integration
- [ ] Unit tests in C++ (Google Test)
- [ ] Integration tests with uWebSockets
- [ ] Load testing (1000 QPS)
- [ ] Documentation and examples
- [ ] Code review

## ‚úÖ Acceptance Criteria
- [ ] All Python text processing functions accessible from C++
- [ ] C++ integration adds <5ms latency per document
- [ ] Thread-safe for concurrent requests
- [ ] Memory efficient (no leaks, proper RAII)
- [ ] Handles 1000+ requests/sec
- [ ] CMake build integration works
- [ ] Unit test coverage ‚â•80%
- [ ] Documentation with C++ usage examples

## üß™ Testing & Validation

### API Integration Test
```cpp
#include "text/TextProcessor.h"

int main() {
    TextProcessor processor;
    
    // Test normalization
    std::string text = "Hello ÿ≥ŸÑÿßŸÖ ‰Ω†Â•Ω";
    std::string normalized = processor.normalize(text);
    
    // Test language detection
    LanguageInfo lang = processor.detect_language(text);
    std::cout << "Language: " << lang.language_code << std::endl;
    std::cout << "Confidence: " << lang.confidence << std::endl;
    
    // Test stopword check
    bool is_stop = processor.is_stopword("the", "en");
    std::cout << "'the' is stopword: " << is_stop << std::endl;
    
    return 0;
}
```

### Performance Benchmark
```bash
# Target: <5ms overhead compared to pure Python
./benchmark_text_processor --iterations 10000
# Expected: C++ wrapper adds <5ms avg latency
```

### Load Test
```bash
# Target: Handle 1000+ QPS
./load_test_text_processor --qps 1000 --duration 60s
# Expected: 0% errors, <100ms P95 latency
```

## üéâ Celebration Criteria (Definition of Done)
‚úÖ **Demo Ready:** C++ app using all text processing features  
‚úÖ **Fast:** <5ms latency overhead  
‚úÖ **Stable:** 1000+ QPS without crashes  
‚úÖ **Integrated:** Works in uWebSockets server  
‚úÖ **Tested:** 80%+ coverage with passing tests  

**üéä Celebration Moment:** Call Python functions from C++ like magic! ü™Ñ

## üì¶ Deliverables
- `include/text/TextProcessor.h` (C++ header, 150 lines)
- `src/text/TextProcessor.cpp` (C++ implementation, 300 lines)
- `src/text/python_bridge.cpp` (pybind11 wrapper, 200 lines)
- `tests/text_processor_test.cpp` (C++ tests, 100+ cases)
- `docs/api/cpp-text-processing.md`
- `CMakeLists.txt` (build configuration updates)

## üîó Dependencies & Integration

### C++ API Design
```cpp
// include/text/TextProcessor.h
#pragma once
#include <string>
#include <vector>

namespace text {

struct LanguageInfo {
    std::string language_code;  // ISO 639-1
    std::string script_code;    // ISO 15924
    float confidence;           // 0.0-1.0
    bool is_mixed_content;
};

class TextProcessor {
public:
    TextProcessor();  // Initializes Python interpreter
    ~TextProcessor(); // Cleanup
    
    // Normalization
    std::string normalize(const std::string& text);
    
    // Language detection
    LanguageInfo detect_language(const std::string& text);
    
    // Stopword checking
    bool is_stopword(const std::string& term, 
                    const std::string& language);
    
    // Batch processing
    std::vector<std::string> normalize_batch(
        const std::vector<std::string>& texts);
    
private:
    class Impl;  // PIMPL idiom
    std::unique_ptr<Impl> impl_;
};

} // namespace text
```

### CMake Integration
```cmake
# Add to CMakeLists.txt
find_package(pybind11 REQUIRED)

add_library(text_processor
    src/text/TextProcessor.cpp
    src/text/python_bridge.cpp
)

target_link_libraries(text_processor
    pybind11::embed
    ${PYTHON_LIBRARIES}
)
```

## üöÄ Next Steps
‚û°Ô∏è **Task 02.1: BM25 Implementation** (4 days)  
- Will use your TextProcessor for document indexing
- Critical for retrieval pipeline

‚û°Ô∏è **üéâ M0 COMPLETE!** After this task, Foundation milestone is DONE!

## üí° Tips & Resources

### Common Pitfalls
- ‚ö†Ô∏è **GIL (Global Interpreter Lock):** Python is single-threaded by default
- ‚ö†Ô∏è **Memory management:** Use RAII for Python objects
- ‚ö†Ô∏è **Error propagation:** Convert Python exceptions to C++ exceptions
- ‚ö†Ô∏è **Initialization:** Call `Py_Initialize()` once at startup

### Helpful Resources
- [pybind11 docs](https://pybind11.readthedocs.io/)
- [Python C API](https://docs.python.org/3/c-api/)
- [CMake FindPython](https://cmake.org/cmake/help/latest/module/FindPython.html)
- [GIL and Threading](https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock)

### Example Implementation
```cpp
// src/text/python_bridge.cpp
#include <pybind11/embed.h>
#include <pybind11/stl.h>

namespace py = pybind11;

class TextProcessor::Impl {
public:
    Impl() {
        // Initialize Python
        py::initialize_interpreter();
        
        // Import modules
        text_module_ = py::module::import("text_processor");
        normalizer_ = text_module_.attr("Normalizer")();
        detector_ = text_module_.attr("LanguageDetector")();
    }
    
    ~Impl() {
        py::finalize_interpreter();
    }
    
    std::string normalize(const std::string& text) {
        try {
            py::object result = normalizer_.attr("normalize")(text);
            return result.cast<std::string>();
        } catch (py::error_already_set& e) {
            throw std::runtime_error(e.what());
        }
    }
    
private:
    py::module text_module_;
    py::object normalizer_;
    py::object detector_;
};
```

## üìä Success Metrics
- **Latency:** <5ms overhead
- **Throughput:** 1000+ QPS
- **Reliability:** 0% crashes under load
- **Memory:** No leaks (valgrind clean)

## üéì Learning Outcomes
After completing this task, you will:
- ‚úÖ Master pybind11 for Python-C++ integration
- ‚úÖ Understand Python C API and GIL
- ‚úÖ Build performant language bridges
- ‚úÖ Write thread-safe C++ code

## üîí Thread Safety Strategy
```cpp
// Option 1: Per-thread Python interpreter (best performance)
thread_local TextProcessor processor;

// Option 2: Mutex protection (simpler, slower)
std::mutex py_lock;
std::lock_guard<std::mutex> guard(py_lock);
processor.normalize(text);

// Option 3: GIL release (for I/O-bound operations)
py::gil_scoped_release release;
// Do C++ work without Python
```

---

**üéä M0 FOUNDATION COMPLETE AFTER THIS! üéä**

