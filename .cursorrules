# Search Engine Core - Cursor AI Rules

## Project Context
This is a high-performance search engine built with C++, uWebSockets, MongoDB, and Redis. The project uses Docker for containerization and includes features like web crawling, SPA rendering, and sponsor management.

## ⚠️ CRITICAL: Zero-Error Development Rules

### MANDATORY: Always Use Correct API Patterns
**NEVER guess API usage - ALWAYS use the correct patterns to prevent compilation errors:**

#### Result<T> Interface (MOST COMMON ERROR SOURCE)
```cpp
// ❌ WRONG - These methods DON'T EXIST and cause 50+ build errors
if (result.isSuccess()) { }
result.getError()
result.getValue()
Result<T>::success(value)
Result<T>::failure(message)

// ✅ CORRECT - Use actual struct interface
if (result.success) { }           // bool member, not method
result.message                    // string member, not getError()
result.value                     // T member, not getValue()
Result<T>::Success(value, "msg") // Static factory with capital S
Result<T>::Failure("error")      // Static factory with capital F
```

#### MongoDB BSON String Access
```cpp
// ❌ WRONG - get_utf8() doesn't exist in current mongocxx driver
element.get_utf8().value.to_string()
element.key().to_string()  // string_view has no to_string()

// ✅ CORRECT - Use current BSON API
std::string(element.get_string().value)
std::string(element.key())
```

#### MongoDB Aggregation Pipeline
```cpp
// ❌ WRONG - Can't pass BSON documents to aggregate()
auto pipeline = document{} << "pipeline" << array{...} << finalize;
collection.aggregate(pipeline.view())

// ✅ CORRECT - Use mongocxx::pipeline class
mongocxx::pipeline pipeline;
pipeline.match(document{} << "field" << "value" << finalize);
pipeline.group(document{} << "_id" << "$field" << finalize);
collection.aggregate(pipeline)
```

#### MongoDB Optional Result Checks
```cpp
// ❌ WRONG - bsoncxx types not directly convertible to bool
if (result) { }                // run_command result
if (!result) { }              // find_one result

// ✅ CORRECT - Use appropriate checks
if (!result.empty()) { }      // for run_command
if (!result.has_value()) { }  // for find_one (std::optional)
```

## Fast Development Workflow

### 1. Code Template Checklist
Before implementing any feature:
- [ ] Use `Result<T>::Success()` and `Result<T>::Failure()` (capital letters)
- [ ] Include MongoDB singleton: `MongoDBInstance::getInstance()`
- [ ] Use lazy initialization for controller services
- [ ] Pair `res->onData()` with `res->onAborted()` for POST endpoints
- [ ] Use `LOG_DEBUG()` instead of `std::cout`
- [ ] Check BSON strings with `std::string(element.get_string().value)`
- [ ] Use `mongocxx::pipeline` for aggregations
- [ ] Use basic builder with `.extract()` for complex MongoDB updates

### 2. Quick Build Verification
```bash
cd /root/search-engine-core && mkdir -p build && cd build
cmake .. && make -j4
```

### 3. Common API Quick Reference
```cpp
// Result usage (ALWAYS use these patterns)
if (result.success) { /* success */ }
auto value = result.value;
auto msg = result.message;

// BSON string extraction (ALWAYS use this pattern)
std::string str = std::string(element.get_string().value);
std::string key = std::string(element.key());

// MongoDB aggregation (ALWAYS use this pattern)
mongocxx::pipeline pipe;
pipe.match(filter).group(grouping);
auto cursor = collection.aggregate(pipe);

// MongoDB updates (ALWAYS use basic builder for complex updates)
using bsoncxx::builder::basic::kvp;
auto setFields = bsoncxx::builder::basic::document{};
setFields.append(kvp("field", "value"));
auto updateDoc = bsoncxx::builder::basic::document{};
updateDoc.append(kvp("$set", setFields.extract()));
collection.update_one(filter, updateDoc.extract());

// Optional checks (ALWAYS use these patterns)
if (findResult.has_value()) { /* found */ }
if (!runCommandResult.empty()) { /* success */ }
```

### 4. Zero-Error Strategy
1. **Copy Working Patterns**: Use the templates above - they always work
2. **Build Frequently**: Compile after every major function/class
3. **Fix Immediately**: Don't accumulate compilation errors
4. **Use Static Analysis**: Let IDE catch issues before building
5. **Follow Patterns**: Stick to established project patterns

## Critical MongoDB C++ Rules

### ⚠️ MOST IMPORTANT: MongoDB Instance Initialization
**NEVER create MongoDB clients without proper instance initialization:**
```cpp
// ❌ WRONG - This will crash the server!
mongocxx::uri uri{"mongodb://localhost:27017"};
client_ = std::make_unique<mongocxx::client>(uri); // CRASH!
```

**ALWAYS use the singleton pattern:**
```cpp
// ✅ CORRECT
#include "../../include/mongodb.h"
mongocxx::instance& instance = MongoDBInstance::getInstance();
mongocxx::uri uri{"mongodb://localhost:27017"};
client_ = std::make_unique<mongocxx::client>(uri); // Works!
```

### MongoDB Integration Checklist
When implementing MongoDB functionality:
1. Include `#include "../../include/mongodb.h"`
2. Call `MongoDBInstance::getInstance()` before creating any client
3. Use consistent collection names across imports and code
4. Add proper exception handling with try-catch blocks
5. Test connection with simple query first

## ⚠️ CRITICAL: MongoDB BSON Document Construction

### MANDATORY: Use Basic Builder for Complex Documents
**NEVER use stream builder for nested documents or update operations - it causes data corruption!**

#### ❌ **WRONG - Stream Builder (Causes Field Deletion)**
```cpp
// ❌ This corrupts MongoDB documents - ALL FIELDS GET DELETED!
document setDoc{};
setDoc << "field1" << value1 << "field2" << value2;  // Not finalized!

document updateDoc{};
updateDoc << "$set" << setDoc  // ❌ Passing unfinalized document!
         << "$push" << open_document 
         << "array" << arrayDoc  // ❌ Mixed builder types!
         << close_document 
         << finalize;

// Result: MongoDB document becomes { _id: ObjectId(...) } - ALL DATA LOST!
```

#### ✅ **CORRECT - Basic Builder (Safe and Reliable)**
```cpp
// ✅ Use basic builder for complex documents
using bsoncxx::builder::basic::kvp;
using bsoncxx::builder::basic::make_document;

// Build $set fields with explicit extraction
auto setFields = bsoncxx::builder::basic::document{};
setFields.append(kvp("field1", value1));
setFields.append(kvp("field2", value2));
setFields.append(kvp("timestamp", bsoncxx::types::b_date{std::chrono::milliseconds{nowMs}}));

// Build nested document (e.g., for array push)
auto nestedDoc = bsoncxx::builder::basic::document{};
nestedDoc.append(kvp("nested_field1", "value"));
nestedDoc.append(kvp("nested_field2", 123));

// Build $push operation
auto pushFields = bsoncxx::builder::basic::document{};
pushFields.append(kvp("history_array", nestedDoc.extract()));  // ✅ Explicit extraction!

// Build final update document
auto updateDoc = bsoncxx::builder::basic::document{};
updateDoc.append(kvp("$set", setFields.extract()));    // ✅ Extract before adding!
updateDoc.append(kvp("$push", pushFields.extract()));  // ✅ Extract before adding!

// Perform update
collection.update_one(filter, updateDoc.extract());  // ✅ Extract final document!
```

### Why Basic Builder vs Stream Builder

#### Stream Builder Problems:
- ❌ Complex state machine requires precise `open_document`/`close_document` pairing
- ❌ Mixing finalized and unfinalized documents causes corruption
- ❌ `.view()` vs `.extract()` confusion leads to use-after-free
- ❌ Nested documents without proper finalization delete all fields
- ❌ Error-prone with multiple MongoDB operators (`$set`, `$push`, `$pull`, etc.)

#### Basic Builder Advantages:
- ✅ **Explicit extraction** - You control document lifecycle with `.extract()`
- ✅ **Clear ownership** - No confusion about when document is finalized
- ✅ **Type safety** - `kvp()` provides compile-time type checking
- ✅ **No state machine** - Each `append()` call is independent
- ✅ **Composability** - Easy to build complex nested structures
- ✅ **Safer** - Prevents data corruption from improper finalization

### When to Use Each Builder

| Use Case | Builder | Why |
|----------|---------|-----|
| **Complex updates** (`$set`, `$push`, etc.) | Basic Builder | Prevents data corruption |
| **Nested documents** (arrays, subdocuments) | Basic Builder | Explicit extraction required |
| **Multiple operators** in one update | Basic Builder | Safer composition |
| **Simple flat queries/filters** | Stream Builder | More concise for simple cases |
| **Production database operations** | Basic Builder | More maintainable and safer |

### BSON Builder Best Practices

#### ✅ **DO: Use Basic Builder Pattern**
```cpp
// Build each level explicitly
auto innerDoc = bsoncxx::builder::basic::document{};
innerDoc.append(kvp("key", "value"));

auto outerDoc = bsoncxx::builder::basic::document{};
outerDoc.append(kvp("nested", innerDoc.extract()));  // ✅ Explicit extraction

collection.insert_one(outerDoc.extract());  // ✅ Final extraction
```

#### ✅ **DO: Use Stream Builder for Simple Filters**
```cpp
// Simple queries are OK with stream builder
auto filter = document{} 
    << "email" << "user@example.com" 
    << "active" << true 
    << finalize;

collection.find_one(filter.view());  // ✅ Simple, flat document
```

#### ❌ **DON'T: Mix Builder Types**
```cpp
// ❌ BAD: Mixing builders
document streamDoc{};
basic::document basicDoc{};
streamDoc << "$set" << basicDoc;  // ❌ Wrong! Use one type consistently
```

#### ❌ **DON'T: Nest Without Extraction**
```cpp
// ❌ BAD: No extraction causes data loss
document parent{};
document child{};
child << "field" << "value";
parent << "nested" << child;  // ❌ Child not extracted - DATA CORRUPTION!
```

### Real-World Example: Update with Multiple Operators

```cpp
// ✅ CORRECT: Complex update operation using basic builder
using bsoncxx::builder::basic::kvp;

// Build $set fields
auto setFields = bsoncxx::builder::basic::document{};
setFields.append(kvp("status", "active"));
setFields.append(kvp("updated_at", bsoncxx::types::b_date{std::chrono::system_clock::now()}));
setFields.append(kvp("counter", 42));

// Build $push array entry
auto historyEntry = bsoncxx::builder::basic::document{};
historyEntry.append(kvp("action", "update"));
historyEntry.append(kvp("timestamp", bsoncxx::types::b_date{std::chrono::system_clock::now()}));
historyEntry.append(kvp("user", "admin"));

auto pushFields = bsoncxx::builder::basic::document{};
pushFields.append(kvp("history", historyEntry.extract()));  // ✅ Extract nested doc

// Build $inc operation
auto incFields = bsoncxx::builder::basic::document{};
incFields.append(kvp("view_count", 1));

// Combine all operations
auto updateDoc = bsoncxx::builder::basic::document{};
updateDoc.append(kvp("$set", setFields.extract()));
updateDoc.append(kvp("$push", pushFields.extract()));
updateDoc.append(kvp("$inc", incFields.extract()));

// Execute update
auto result = collection.update_one(
    make_document(kvp("_id", documentId)),
    updateDoc.extract()
);

// Result: All fields preserved, operations applied correctly ✅
```

### BSON Document Checklist
When working with MongoDB documents:
- [ ] **Use basic builder for ANY nested structures**
- [ ] **Use basic builder for multiple operators** (`$set`, `$push`, `$pull`, etc.)
- [ ] **Call `.extract()` on each subdocument before adding to parent**
- [ ] **Call `.extract()` on final document before passing to MongoDB**
- [ ] **Use `kvp()` for type-safe key-value pairs**
- [ ] **Test update operations to verify no data loss**
- [ ] **Stream builder ONLY for simple, flat filters/queries**

### Common BSON Errors and Solutions

#### Error: All Fields Deleted Except `_id`
**Symptom:** After update, document becomes `{ _id: ObjectId(...) }`

**Cause:** Stream builder used without proper finalization

**Solution:** Switch to basic builder with explicit `.extract()` calls

#### Error: `modified_count() == 0` but document exists
**Symptom:** Update returns 0 modified documents

**Cause:** Malformed BSON from improper builder usage

**Solution:** Use basic builder and verify BSON structure

#### Error: Nested arrays/objects not updating
**Symptom:** Nested fields remain unchanged after update

**Cause:** Nested documents not extracted before adding to parent

**Solution:** Call `.extract()` on nested document before `append()`

## Build and Deployment Rules

### Local Build Process
```bash
cd /root/search-engine-core
mkdir -p build && cd build
cmake .. && make -j4
```

### Docker Deployment
```bash
# Build locally and copy to container
docker cp /root/search-engine-core/build/server core:/app/server
docker restart core

# Or use Docker Compose
cd /root/search-engine-core
docker compose up --build
```

## Code Style and Patterns

### Controller Registration
**CRITICAL: Controllers MUST NOT use namespaces **

All new API endpoints must be registered in the controller header file using the `ROUTE_CONTROLLER` pattern:

```cpp
// ❌ WRONG - Controllers should NOT use namespaces
namespace search_engine {
namespace controllers {
    class MyController : public routing::Controller { ... };
} // This breaks ROUTE_CONTROLLER macro!
}

// ✅ CORRECT - Controllers are in global namespace
// In MyController.h
#include "../../include/routing/Controller.h"
#include "../../include/routing/RouteRegistry.h"

class MyController : public routing::Controller {
public:
    MyController();
    
    // API Endpoints
    void myEndpoint(uWS::HttpResponse<false>* res, uWS::HttpRequest* req);
    void anotherEndpoint(uWS::HttpResponse<false>* res, uWS::HttpRequest* req);
};

// Route registration - OUTSIDE the class, at bottom of header file
ROUTE_CONTROLLER(MyController) {
    using namespace routing;
    REGISTER_ROUTE(HttpMethod::GET, "/api/v2/my-endpoint", myEndpoint, MyController);
    REGISTER_ROUTE(HttpMethod::POST, "/api/v2/another-endpoint", anotherEndpoint, MyController);
}
```

**Controller Architecture Rules:**
- ✅ **NO namespaces** for controllers 
- ✅ Use `ROUTE_CONTROLLER(ClassName)` macro in header file
- ✅ Place route registration at bottom of header, after class definition
- ✅ Use `REGISTER_ROUTE` for each endpoint inside `ROUTE_CONTROLLER` block
- ✅ Controller class name only (no namespace prefix in macros)
- ❌ **NEVER** create separate `*_routes.cpp` files
- ❌ **NEVER** wrap controller classes in namespaces

### Error Handling Pattern
```cpp
try {
    // MongoDB operations
    mongocxx::instance& instance = MongoDBInstance::getInstance();
    // ... rest of code
} catch (const mongocxx::exception& e) {
    LOG_ERROR("MongoDB error: " + std::string(e.what()));
    serverError(res, "Database error occurred");
}
```

### Logging Standards
- Use `LOG_INFO()` for normal operations
- Use `LOG_ERROR()` for errors
- Use `LOG_DEBUG()` for debugging (only in debug builds)
- Use `LOG_WARNING()` for warnings

## ⚠️ CRITICAL: Configurable Debug Output Rules

### MANDATORY: Environment-Based Debug Configuration
**NEVER use hardcoded debug output - ALWAYS make it configurable via LOG_LEVEL:**

```cpp
// ❌ WRONG - Hardcoded debug output (breaks production performance)
std::cout << "[DEBUG] Processing request: " << requestId << std::endl;

// ✅ CORRECT - Configurable debug logging
LOG_DEBUG("Processing request: " + std::to_string(requestId));

// ✅ EVEN BETTER - Structured debug logging
LOG_DEBUG("Processing request with ID: " + std::to_string(requestId) +
          ", method: " + std::string(method) +
          ", timestamp: " + getCurrentTimestamp());
```

### Debug Output Configuration Rules

1. **ALWAYS use `LOG_DEBUG()` instead of `std::cout`** for debug messages
2. **NEVER use `std::cout`** for application debug output
3. **ALWAYS configure log level via `LOG_LEVEL` environment variable**
4. **NEVER hardcode debug verbosity** - let environment control it
5. **ALWAYS test with different log levels** before committing

### LOG_LEVEL Environment Variable Usage

```bash
# Development - Full debug output
LOG_LEVEL=debug docker-compose up

# Production - Standard logging only
LOG_LEVEL=info docker-compose up

# High-performance - Minimal logging
LOG_LEVEL=warning docker-compose up

# Silent operation - Errors only
LOG_LEVEL=error docker-compose up

# No logging - Maximum performance
LOG_LEVEL=none docker-compose up
```

### Available Log Levels

| Level | Use Case | What Gets Logged |
|-------|----------|------------------|
| `trace` | Deep debugging | Everything including execution flow |
| `debug` | Development | WebSocket, crawler, API calls, performance |
| `info` | Production | Standard operations, system status |
| `warning` | High-performance | Non-critical issues, performance warnings |
| `error` | Critical monitoring | System failures, database errors |
| `none` | Performance testing | No logging output |

### Debug Output Migration Checklist

When adding new debug output:
1. [ ] **Use `LOG_DEBUG()` instead of `std::cout`**
2. [ ] **Test with `LOG_LEVEL=debug`** to ensure output appears
3. [ ] **Test with `LOG_LEVEL=info`** to ensure output is suppressed
4. [ ] **Document the debug message purpose** in comments
5. [ ] **Use structured logging** with clear, searchable messages

### Why Configurable Debug Output Matters

1. **Performance**: Debug output can significantly slow down production systems
2. **Security**: Debug messages might leak sensitive information
3. **Monitoring**: Clean production logs are essential for monitoring
4. **Scalability**: Debug output affects log aggregation and storage costs
5. **Compliance**: Production systems often require clean, controlled logging

### Legacy Code Migration Pattern

For existing `std::cout` debug statements:

```cpp
// BEFORE (Legacy code - DO NOT USE)
std::cout << "[DEBUG] User " << userId << " logged in" << std::endl;

// AFTER (Modern approach - ALWAYS USE)
LOG_DEBUG("User " + std::to_string(userId) + " logged in successfully");
```

### Testing Debug Configuration

Always test your debug output with different log levels:

```bash
# Test debug level (should show debug messages)
LOG_LEVEL=debug ./server

# Test info level (should hide debug messages)
LOG_LEVEL=info ./server

# Test production level (should hide debug messages)
LOG_LEVEL=warning ./server
```

## ⚠️ CRITICAL: uWebSockets Rules

### MANDATORY: onData + onAborted Pattern
**NEVER use `res->onData()` without `res->onAborted()`:**

```cpp
// ❌ WRONG - This will crash the server when client disconnects!
res->onData([this, res, buffer = std::move(buffer)](std::string_view data, bool last) mutable {
    buffer.append(data.data(), data.length());
    if (last) {
        // Process request...
    }
});
// Missing onAborted() - SERVER CRASH!
```

**ALWAYS pair onData with onAborted:**

```cpp
// ✅ CORRECT - Safe from client disconnections
res->onData([this, res, buffer = std::move(buffer)](std::string_view data, bool last) mutable {
    buffer.append(data.data(), data.length());
    if (last) {
        // Process request...
    }
});

res->onAborted([]() {
    LOG_WARNING("Request aborted by client");
});
```

### uWebSockets Integration Checklist
When implementing POST/PUT endpoints with request body:
1. **ALWAYS** add `res->onAborted()` after `res->onData()`
2. Use `std::move(buffer)` in lambda capture for performance
3. Check `if (last)` before processing complete request
4. Add appropriate logging in `onAborted` for debugging
5. Never access `res` or controller members after client disconnect

### Common uWebSockets Crashes
- **"Empty reply from server"** → Missing `onAborted()` callback
- **Segmentation fault in POST** → Client disconnect without `onAborted()` handling
- **Undefined behavior in lambdas** → Accessing invalid `this` pointer after disconnect

### uWebSockets Best Practices
```cpp
// Template for safe POST endpoint
void Controller::safePostEndpoint(uWS::HttpResponse<false>* res, uWS::HttpRequest* req) {
    std::string buffer;
    res->onData([this, res, buffer = std::move(buffer)](std::string_view data, bool last) mutable {
        buffer.append(data.data(), data.length());
        
        if (last) {
            try {
                // Process request safely
                auto jsonBody = nlohmann::json::parse(buffer);
                // ... business logic ...
                this->json(res, response);
            } catch (const std::exception& e) {
                LOG_ERROR("Error in endpoint: " + std::string(e.what()));
                serverError(res, "Processing error");
            }
        }
    });

    // CRITICAL: Always add this
    res->onAborted([]() {
        LOG_WARNING("Client disconnected during request processing");
    });
}
```

## ⚠️ CRITICAL: Controller Initialization Rules

### MANDATORY: Lazy Initialization Pattern
**NEVER initialize services in controller constructors (static initialization order fiasco):**

```cpp
// ❌ WRONG - This causes static initialization order fiasco!
class DomainController : public routing::Controller {
public:
    DomainController() {
        // BAD: Initializing during static initialization before main()
        domainStorage_ = std::make_unique<DomainStorage>();  // Can crash!
        jobQueue_ = std::make_unique<JobQueue>();           // Can crash!
    }
private:
    std::unique_ptr<DomainStorage> domainStorage_;
    std::unique_ptr<JobQueue> jobQueue_;
};
```

**ALWAYS use lazy initialization with getter methods:**

```cpp
// ✅ CORRECT - Safe lazy initialization pattern
class DomainController : public routing::Controller {
public:
    DomainController() {
        // Empty constructor - no initialization during static startup
    }
    
private:
    mutable std::unique_ptr<DomainStorage> domainStorage_;
    mutable std::unique_ptr<JobQueue> jobQueue_;
    
    // Lazy initialization helpers
    DomainStorage* getDomainStorage() const {
        if (!domainStorage_) {
            try {
                LOG_INFO("Lazy initializing DomainStorage");
                domainStorage_ = std::make_unique<DomainStorage>();
            } catch (const std::exception& e) {
                LOG_ERROR("Failed to lazy initialize DomainStorage: " + std::string(e.what()));
                throw;
            }
        }
        return domainStorage_.get();
    }
    
    JobQueue* getJobQueue() const {
        if (!jobQueue_) {
            try {
                LOG_INFO("Lazy initializing JobQueue");
                jobQueue_ = std::make_unique<JobQueue>();
            } catch (const std::exception& e) {
                LOG_ERROR("Failed to lazy initialize JobQueue: " + std::string(e.what()));
                throw;
            }
        }
        return jobQueue_.get();
    }
};
```

### Why Lazy Initialization is Critical
1. **Prevents Static Initialization Order Fiasco:** Services initialize after Docker containers are ready
2. **Better Error Handling:** Can catch and handle initialization failures gracefully
3. **Resource Efficiency:** Only creates objects when actually needed
4. **Timing Independence:** No race conditions with service startup
5. **Testability:** Easy to mock and test individual components

### Lazy Initialization Checklist
When creating controllers with service dependencies:
1. **NEVER** initialize services in constructor
2. **ALWAYS** declare service members as `mutable std::unique_ptr<Service>`
3. **ALWAYS** create lazy getter methods with proper error handling
4. **ALWAYS** use getter methods instead of direct member access
5. **ALWAYS** add logging for initialization events

## File Organization

### Header Includes
```cpp
// System headers first
#include <string>
#include <memory>

// Project headers
#include "../../include/Logger.h"
#include "../../include/mongodb.h"

// Third-party headers
#include <mongocxx/client.hpp>
#include <nlohmann/json.hpp>
```

### CMake Integration
When adding new storage classes:
1. Add to `src/storage/CMakeLists.txt`
2. Create static library target
3. Link to main server executable
4. Include in install targets

## API Response Format

### Success Response
```json
{
  "success": true,
  "message": "Operation completed successfully",
  "data": { ... }
}
```

### Error Response
```json
{
  "success": false,
  "message": "Error description",
  "error": "ERROR_CODE"
}
```

## Testing Guidelines

### MongoDB Connection Test
```bash
docker exec mongodb_test mongosh --username admin --password password123 \
--eval "db.adminCommand('ping')"
```

### API Testing
```bash
curl --location 'http://localhost:3000/api/endpoint' \
--header 'Content-Type: application/json' \
--data-raw '{ ... }'
```

### Verify Data Storage
```bash
docker exec mongodb_test mongosh --username admin --password password123 \
--eval "use('search-engine'); db.collection.find().pretty()"
```

## Common Issues and Solutions

### Server Crash: "Empty reply from server" (Most Common)
**Cause:** Missing `res->onAborted()` callback after `res->onData()`
**Solution:** Always pair every `res->onData()` with `res->onAborted()`

### Server Crash: MongoDB Connection
**Cause:** MongoDB instance not initialized
**Solution:** Use `MongoDBInstance::getInstance()` before creating clients

### Server Crash: Static Initialization Order Fiasco
**Cause:** Controller constructor initializes services during static startup (before Docker containers ready)
**Solution:** Use lazy initialization pattern with getter methods instead of constructor initialization

### POST Endpoints Crash on Client Disconnect
**Cause:** Client disconnects during `onData` processing without `onAborted` handler
**Solution:** Add `res->onAborted([](){ LOG_WARNING("Request aborted"); });`

### Undefined Reference Errors
**Cause:** Missing library in CMakeLists.txt
**Solution:** Add library to target_link_libraries in CMakeLists.txt

### Collection Not Found
**Cause:** Inconsistent collection names
**Solution:** Use same collection name in code and imports

## Docker Environment

### Container Names
- `core` - Main application server
- `mongodb_test` - MongoDB database
- `redis` - Redis cache
- `browserless` - Headless Chrome for SPA rendering

### Environment Variables
- `LOG_LEVEL` - **CRITICAL**: Logging verbosity level (debug, info, warning, error, none)
- `MONGODB_URI` - MongoDB connection string (default: mongodb://admin:password123@mongodb:27017)
- `REDIS_URL` - Redis connection string
- `BROWSERLESS_URL` - Browserless service URL

## ✅ **Environment Variable Configuration Best Practices**

### MANDATORY: Use Direct Environment Variable Access
**ALWAYS use `std::getenv()` for configuration - works perfectly with Docker Compose:**

```cpp
// ✅ CORRECT - Simple and reliable approach
search_engine::storage::EmailService::SMTPConfig EmailController::loadSMTPConfig() const {
    search_engine::storage::EmailService::SMTPConfig config;
    
    // Load from environment variables (works with Docker Compose and .env files)
    const char* smtpHost = std::getenv("SMTP_HOST");
    config.smtpHost = smtpHost ? smtpHost : "smtp.gmail.com";
    
    const char* smtpPort = std::getenv("SMTP_PORT");
    config.smtpPort = smtpPort ? std::stoi(smtpPort) : 587;
    
    const char* useTLS = std::getenv("SMTP_USE_TLS");
    if (useTLS) {
        std::string tlsStr = std::string(useTLS);
        std::transform(tlsStr.begin(), tlsStr.end(), tlsStr.begin(), ::tolower);
        config.useTLS = (tlsStr == "true" || tlsStr == "1" || tlsStr == "yes");
    } else {
        config.useTLS = true; // Default value
    }
    
    return config;
}
```

### Environment Variable Compatibility

This approach is simpler and works perfectly with:
- ✅ **Docker Compose environment variables** (primary method for containers)
- ✅ **System environment variables** (for local development)  
- ✅ **`.env` files** (Docker Compose reads them automatically)

### Docker Compose Integration Pattern

```yaml
# docker-compose.yml
environment:
  - SMTP_HOST=${SMTP_HOST:-smtp.gmail.com}
  - SMTP_PORT=${SMTP_PORT:-587}
  - SMTP_USE_TLS=${SMTP_USE_TLS:-true}
  - SMTP_USERNAME=${SMTP_USERNAME}
  - SMTP_PASSWORD=${SMTP_PASSWORD}
  - FROM_EMAIL=${FROM_EMAIL:-noreply@hatef.ir}
```

### Configuration Priority Order

1. **Docker environment** (highest priority)
2. **`.env` file** (fallback for Docker Compose)
3. **Default values** (built-in fallbacks in code)

### Environment Variable Best Practices

#### Boolean Environment Variables
```cpp
// ✅ CORRECT - Handle boolean environment variables properly
const char* useTLS = std::getenv("SMTP_USE_TLS");
if (useTLS) {
    std::string tlsStr = std::string(useTLS);
    std::transform(tlsStr.begin(), tlsStr.end(), tlsStr.begin(), ::tolower);
    config.useTLS = (tlsStr == "true" || tlsStr == "1" || tlsStr == "yes");
} else {
    config.useTLS = true; // Default
}
```

#### Integer Environment Variables  
```cpp
// ✅ CORRECT - Handle integer environment variables with error checking
const char* smtpPort = std::getenv("SMTP_PORT");
try {
    config.smtpPort = smtpPort ? std::stoi(smtpPort) : 587;
} catch (const std::exception& e) {
    LOG_WARNING("Invalid SMTP_PORT value, using default: 587");
    config.smtpPort = 587;
}
```

#### String Environment Variables
```cpp
// ✅ CORRECT - Handle string environment variables with defaults
const char* smtpHost = std::getenv("SMTP_HOST");
config.smtpHost = smtpHost ? smtpHost : "smtp.gmail.com";
```

### Why Avoid Custom .env Parsers

❌ **DON'T** create custom EnvLoader classes:
- Complex to implement correctly
- Linking issues in static libraries  
- Reinventing what Docker Compose already provides
- Additional maintenance burden

✅ **DO** use direct `std::getenv()`:
- Simple and reliable
- No external dependencies
- Works everywhere (Docker, system, CI/CD)
- Docker Compose handles `.env` files automatically

### Environment Variable Security

1. **NEVER** commit `.env` files with credentials to git
2. **ALWAYS** add `.env` to `.gitignore`
3. **USE** Docker secrets or environment injection in production
4. **PROVIDE** meaningful defaults for non-sensitive values
5. **VALIDATE** required environment variables at startup

## Frontend Integration

### Static Files
- Location: `/public/` directory
- Served by: StaticFileController
- Caching: 1-year browser cache for JS/CSS

### Templates
- Location: `/templates/` directory
- Engine: Inja templating
- Localization: `/locales/` directory

### Localization Structure Rules

#### ⚠️ MANDATORY: Language-Specific Folder Structure
**NEVER place localization files in the root of locales folder - ALWAYS use language-specific subfolders:**

```
// ❌ WRONG - Files in root locales directory
locales/
├── en.json
├── fa.json
├── de.json
└── fr.json

// ✅ CORRECT - Language-specific folders with descriptive names
locales/
├── en/
│   ├── common.json
│   ├── crawling-notification.json
│   └── sponsor.json
├── fa/
│   ├── common.json
│   ├── crawling-notification.json
│   └── sponsor.json
├── de/
│   └── common.json
└── languages.json (language metadata)
```

#### Localization File Organization Rules

1. **ALWAYS** create a dedicated folder for each language code (`en/`, `fa/`, `de/`, etc.)
2. **ALWAYS** use descriptive file names within language folders (`common.json`, `crawling-notification.json`, `sponsor.json`)
3. **NEVER** place translation files directly in `/locales/` root
4. **ALWAYS** keep `languages.json` in the root for language metadata
5. **ALWAYS** follow consistent naming conventions across all language folders

#### Loading Localization Files in Code

```cpp
// ✅ CORRECT - Load from language-specific folder
std::string localesPath = "locales/" + lang + "/crawling-notification.json";
std::string localeContent = loadFile(localesPath);

// For fallback loading
if (localeContent.empty()) {
    LOG_WARNING("Failed to load locale file: " + localesPath + ", falling back to English");
    localesPath = "locales/en/crawling-notification.json";
    localeContent = loadFile(localesPath);
}
```

#### Localization Checklist

When adding new localized content:
- [ ] Create language-specific folders (`locales/en/`, `locales/fa/`, etc.)
- [ ] Use descriptive file names (not just language codes)
- [ ] Update code to load from correct folder structure
- [ ] Ensure fallback loading works for missing translations
- [ ] Keep `languages.json` in root for metadata

### CSS Best Practices

#### ⚠️ CSS Class Reuse and DRY Principle
**ALWAYS prefer reusing existing CSS classes over creating new ones:**

```css
/* ❌ WRONG - Duplicating styles */
.new-component {
    padding: var(--space-4) 0;
    font-family: "Vazirmatn FD", "Vazirmatn", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}

.another-component {
    padding: var(--space-4) 0;
    font-family: "Vazirmatn FD", "Vazirmatn", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
```

**✅ CORRECT - Using CSS custom properties and reusing classes:**
```css
:root {
    --font-family: "Vazirmatn FD", "Vazirmatn", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}

.content-section {
    padding: var(--space-4) 0;
    font-family: var(--font-family);
}

/* Reuse the existing class */
.new-component {
    /* Extend existing class or use utility classes */
}
```

#### CSS Custom Properties (Variables)
- **ALWAYS** define reusable values as CSS custom properties in `:root`
- Use semantic names: `--font-family`, `--primary-color`, `--border-radius`
- Reference existing variables before creating new ones
- Group related variables together

#### Class Naming and Organization
- Use BEM methodology for component-specific classes
- Create utility classes for common patterns (spacing, typography, colors)
- Prefer composition over inheritance
- Document complex CSS patterns with comments

#### CSS Checklist
Before adding new CSS:
- [ ] Check if existing classes can be reused
- [ ] Verify if CSS custom properties already exist for the values
- [ ] Consider creating utility classes for repeated patterns
- [ ] Use semantic class names
- [ ] Follow the existing CSS architecture

### JavaScript Best Practices

#### ⚠️ NO Inline JavaScript - Content Security Policy Compliance
**NEVER use inline event handlers (onclick, onload, etc.) due to CSP restrictions:**

```javascript
// ❌ WRONG - Inline JavaScript (violates CSP)
<button onclick="copyToClipboard('text')">Copy</button>
<span onclick="handleClick()">Click me</span>

// ✅ CORRECT - Use data attributes and event listeners
<button data-copy-text="text" class="copy-btn">Copy</button>
<span data-action="click" class="clickable">Click me</span>

// Add event listeners in JavaScript
document.querySelectorAll('.copy-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const text = this.getAttribute('data-copy-text');
        copyToClipboard(text);
    });
});
```

#### JavaScript Security Rules
- **ALWAYS** use `data-*` attributes instead of inline event handlers
- **ALWAYS** attach event listeners using `addEventListener()`
- **NEVER** use `onclick`, `onload`, `onsubmit`, etc. in HTML
- **ALWAYS** use event delegation for dynamically created elements
- **ALWAYS** follow CSP (Content Security Policy) guidelines

#### JavaScript Event Handling Pattern
```javascript
// ✅ CORRECT Pattern for reusable components
function createCopyButton(text, label) {
    const button = document.createElement('button');
    button.className = 'copy-btn';
    button.setAttribute('data-copy-text', text);
    button.setAttribute('title', label);
    button.innerHTML = '<svg>...</svg>';
    
    // Add event listener
    button.addEventListener('click', function() {
        const textToCopy = this.getAttribute('data-copy-text');
        copyToClipboard(textToCopy);
    });
    
    return button;
}
```

#### JavaScript Checklist
Before adding new JavaScript:
- [ ] No inline event handlers (onclick, onload, etc.)
- [ ] Use data attributes for dynamic content
- [ ] Add event listeners in JavaScript code
- [ ] Follow CSP guidelines
- [ ] Use event delegation for dynamic elements
- [ ] Implement proper error handling

### ⚠️ CRITICAL: Link Management - Base URL Usage
**NEVER use hardcoded URLs for internal links - ALWAYS use `{{ base_url }}` for proper environment handling:**

```html
<!-- ❌ WRONG - Hardcoded localhost URLs (breaks in different environments) -->
<a href="http://localhost:3000/crawl-request">Crawl Request</a>
<a href="http://localhost:3000/about">About</a>

<!-- ✅ CORRECT - Use base_url variable for environment flexibility -->
<a href="{{ base_url }}/crawl-request">Crawl Request</a>
<a href="{{ base_url }}/about">About</a>
```

#### Link URL Best Practices

1. **ALWAYS** use `{{ base_url }}` for internal application links
2. **ALWAYS** use `{{ base_url }}` for API endpoints, search forms, and navigation
3. **NEVER** hardcode localhost URLs, port numbers, or absolute paths in templates
4. **EXCEPTIONS**: External links (GitHub, social media) remain absolute URLs
5. **ALWAYS** test links work across development, staging, and production environments

#### Link URL Checklist
When adding new links to templates:
- [ ] Use `{{ base_url }}` prefix for all internal links
- [ ] Never hardcode localhost URLs or port numbers
- [ ] Verify links work in different environments
- [ ] Keep external links as absolute URLs (GitHub, social media, etc.)
- [ ] Ensure link accessibility with proper `aria-label` or text content

## Security Best Practices

1. Always validate input data
2. Use prepared statements for database queries
3. Implement rate limiting for APIs
4. Use HTTPS in production
5. Sanitize user-provided URLs
6. Validate email formats
7. Check mobile number formats

## Performance Optimization

1. Use connection pooling for MongoDB
2. Implement Redis caching for frequently accessed data
3. Use async operations where possible
4. Minimize database round trips
5. Use indexes on frequently queried fields

## Documentation Requirements

When adding new features:
1. Update `README.md` with feature description
2. Add API documentation to `docs/api/`
3. Update project structure if new files added
4. Document any new environment variables
5. Add examples to documentation

## Git Commit Messages

Format: `type: description`

Types:
- `feat:` New feature
- `fix:` Bug fix
- `docs:` Documentation changes
- `refactor:` Code refactoring
- `test:` Test additions/changes
- `perf:` Performance improvements
- `chore:` Maintenance tasks

## Code Review Checklist

Before submitting code:
- [ ] **uWebSockets: Every `onData` paired with `onAborted`**
- [ ] **Controllers: Use lazy initialization pattern (no service init in constructor)**
- [ ] **Debug Output: Use `LOG_DEBUG()` instead of `std::cout` (configurable via LOG_LEVEL)**
- [ ] **MongoDB BSON: Use basic builder for complex updates (with `.extract()` calls)**
- [ ] MongoDB instance properly initialized
- [ ] Error handling implemented
- [ ] Logging added for debugging
- [ ] Documentation updated
- [ ] Tests written/updated
- [ ] CMakeLists.txt updated if needed
- [ ] No memory leaks
- [ ] Thread-safe where required

## Important File Paths

- Controllers: `src/controllers/`
- Storage: `src/storage/`
- Headers: `include/`
- MongoDB singleton: `include/mongodb.h`
- API docs: `docs/api/`
- Templates: `templates/`
- Static files: `public/`

## Memory Management

1. Use smart pointers (`std::unique_ptr`, `std::shared_ptr`)
2. Avoid raw pointers unless necessary
3. RAII pattern for resource management
4. Clean up in destructors

## Thread Safety

1. Use mutexes for shared resources
2. Prefer lock_guard over manual lock/unlock
3. Minimize lock scope
4. Avoid deadlocks with consistent lock ordering

## Debugging Tips

1. Check Docker logs: `docker logs core --tail 50`
2. MongoDB logs: `docker logs mongodb_test`
3. Use `LOG_DEBUG()` liberally during development
4. Test with curl before UI integration
5. Verify MongoDB connection independently

## Production Deployment

1. Set appropriate environment variables
2. Enable HTTPS
3. Configure proper MongoDB authentication
4. Set up monitoring and alerting
5. Implement backup strategies
6. Use production Docker images from GHCR

Remember:
1. Always test MongoDB connections with the singleton pattern to avoid server crashes!
2. **CRITICAL: Every `res->onData()` MUST be paired with `res->onAborted()` to prevent crashes!**
3. **CRITICAL: Use lazy initialization in controllers - NEVER initialize services in constructors!**
4. **CRITICAL: Use `LOG_DEBUG()` instead of `std::cout` - configure via `LOG_LEVEL` environment variable!**
5. **CRITICAL: Use basic builder with `.extract()` for MongoDB complex updates - stream builder causes data corruption!**